//  Copyright 2022 fy <fy0748@gmail.com>
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package dicescript

type Parser Peg {
    ParserData
    Context
}

// 出口
dicescript <- sp stmtRoot { p.AddOp(TypeHalt) }
stmtRoot <- stmtLines
stmtRootInLoop <- stmtLinesInLoop

stmtLines <- stmtWithBlock stmtLines*
           / stmtWithSemicolon ((';' sp)+ stmtWithSemicolon / (';' sp)* stmtWithBlock stmtLines*)*
           / (';' sp)+

stmtLinesInLoop <- (stmtWithBlock / stmtBreak / stmtContinue) stmtLinesInLoop*
                 / stmtWithSemicolon ((';' sp)+ stmtWithSemicolon / (';' sp)* (stmtWithBlock stmtLinesInLoop* / stmtBreak / stmtContinue))*
                 / (';' sp)+

stmtWithSemicolon <- stmtAssign / exprRoot

stmtWithBlock <- stmtIf / stmtFunc / stmtWhile / stmtReturn

stmtBreak <- 'break' sp { p.BreakPush() }

stmtContinue <- 'continue' sp { p.ContinuePush() }

stmtReturn <- 'return' sp1 exprRoot { p.AddOp(TypeReturn); }
            / 'return' sp { p.PushUndefined(); p.AddOp(TypeReturn); }

blockInLoop <- ( '{' sp '}' / '{' sp stmtRootInLoop '}' ) sp
stmtWhile <- 'while' { p.OffsetPush() } sp1 exprRoot { p.AddOp(TypeJne); p.OffsetPush() }
             blockInLoop { p.AddOp(TypeJmp); p.OffsetPush(); p.OffsetJmpSetX(0, 2, true); p.OffsetJmpSetX(1, 1, false); p.ContinueSet(2); p.BreakSet(); p.OffsetPopN(3); }
// push xxx // 这里是while后面的exprRoot
// jne 1
// ...
// jmp -3 // 跳回开始点

block <- ( '{' sp '}' / '{' sp stmtRoot '}' ) sp
stmtElse <- 'else' sp1 (block / stmtIf)
stmtIf <- 'if' sp1 exprRoot { p.AddOp(TypeJne); p.OffsetPush() } block { p.AddOp(TypeJmp); p.OffsetPopAndSet(); p.OffsetPush(); }
           stmtElse? { p.OffsetPopAndSet() }
// 'if' exprRoot block
// ('else' block)?

// if ... then .. else
// push 1
// jne 2
// push "ret1"
// jmp 1
// push "ret2"

// 函数定义
func_def_params <- '(' sp ')' sp { p.CounterPush() }
                 / '(' sp { p.CounterPush(); p.CounterAdd(1) } identifier { p.NamePush(text) } (',' sp identifier { p.NamePush(text) } {p.CounterAdd(1)} )* ')' sp

stmtFunc <- 'func' sp1 identifier { p.NamePush(text) } func_def_params '{' sp { p.CodePush() } < stmtRoot? > '}' sp
            {  num := p.CounterPop(); arr := []string{}; for i:=int64(0); i<num; i++ { arr = append(arr, p.NamePop()) }; p.AddStoreFunction(p.NamePop(), arr, string(text)) }

// 赋值
stmtAssign <- identifier { p.NamePush(text) } '=' sp exprRoot { p.AddStore(p.NamePop()) }
            / '&' identifier { p.NamePush(text) } '=' sp { p.CodePush() } < exprRoot > { p.AddStoreComputed(p.NamePop(), string(text)) }
            / identifier { p.NamePush(text) } '.' sp identifier { p.NamePush(text) } '=' sp exprRoot { attr, objName := p.NamePop(), p.NamePop(); p.AddSetAttr(objName, attr) }
            / exprRoot '[' sp exprRoot ']' sp '=' sp exprRoot { p.AddOp(TypeSetItem) }

exprRoot <- exprTernary


// 三元算符 ? :
exprValueIfExists <- exprBitwise '?' sp { p.AddOp(TypeJne); p.OffsetPush() } exprBitwise { p.AddOp(TypeJmp); p.OffsetPopAndSet(); p.OffsetPush(); } // 这里的Pop对应的是jne，所有jmp将攒到最后
exprTernary <- exprBitwise '?' sp { p.AddOp(TypeJne); p.OffsetPush() } exprBitwise ':' sp { p.AddOp(TypeJmp); p.OffsetPopAndSet(); p.OffsetPush() } exprBitwise { p.OffsetPopAndSet() }
        / exprValueIfExists { p.CounterPush() } ( ',' sp exprValueIfExists {p.CounterAdd(1)} )*  { p.PushStr(""); limit:=p.CounterPop()+1; for i:=int64(0); i<limit; i++ { p.OffsetPopAndSet() } }
        / exprBitwise

// switch { case 1: ..., case 2: ... }
// push cond1
// jne 2
// push "ret1"
// jmp 5
// push cond2
// jne 2
// push "ret2"
// jmp 1
// push 0 // 默认
// push "ret3"


// 位运算
exprBitwise <- exprCompare ((logicOr / bitwiseOr) { p.LMark() } exprCompare { p.AddOp(TypeBitwiseOr) }
                 / (logicAnd / bitwiseAnd) { p.LMark() } exprCompare { p.AddOp(TypeBitwiseAnd) } )*


// 比较
exprCompare <- exprAdditive (
                 lt { p.LMark() } exprAdditive { p.AddOp(TypeCompLT) }
               / le { p.LMark() } exprAdditive { p.AddOp(TypeCompLE) }
               / eq { p.LMark() } exprAdditive { p.AddOp(TypeCompEQ) }
               / ne { p.LMark() } exprAdditive { p.AddOp(TypeCompNE) }
               / ge { p.LMark() } exprAdditive { p.AddOp(TypeCompGE) }
               / gt { p.LMark() } exprAdditive { p.AddOp(TypeCompGT) }
             )*

// 加减
exprAdditive <- exprMultiplicative (
                  add { p.LMark() } exprMultiplicative { p.AddOp(TypeAdd) }
                / minus { p.LMark() } exprMultiplicative { p.AddOp(TypeSubtract) }
              )*

// 乘除余
exprMultiplicative <- exprExp (
                        multiply { p.LMark() } exprExp { p.AddOp(TypeMultiply) }
                      / divide { p.LMark() } exprExp { p.AddOp(TypeDivide) }
                      / modulus { p.LMark() } exprExp { p.AddOp(TypeModulus) }
                    )*

// 平方
exprExp <- exprUnaryNeg (
             exponentiation { p.LMark() } exprUnaryNeg { p.AddOp(TypeExponentiation) }
         )*


// 正数 负数
exprUnaryNeg <- minus exprRoot { p.AddOp(TypeNegation) }
              / exprUnaryPos

exprUnaryPos <- add exprRoot { p.AddOp(TypePositive) }
              / exprDice

// 骰子算符，注: 越靠下的算符优先级越高
_diceMod <- (('kl' / [qQ]) (number / sub) { p.AddOp(TypeDiceSetKeepLowNum) } )  // 这里fvtt只有kl
          / (('kl' / [qQ]) { p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepLowNum) } )
          / (('kh' / [kK]) (number / sub) { p.AddOp(TypeDiceSetKeepHighNum) })  // 这里fvtt与国内骰一致
          / (('kh' / [kK]) { p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepHighNum) })
          / (('dh') (number / sub) { p.AddOp(TypeDiceSetDropHighNum) } ) // drop highest，需要在下一个之前，因为有2d20d1语法
          / (('dh') { p.PushIntNumber("1"); p.AddOp(TypeDiceSetDropHighNum) } )
          / (('dl') (number / sub) { p.AddOp(TypeDiceSetDropLowNum) } )  // drop lowest, 这里故意去掉了3d20d1 的支持，需要写成3d20dl1
          / (('dl') { p.PushIntNumber("1"); p.AddOp(TypeDiceSetDropLowNum) } )

_diceMod2 <- ('min' (number / sub) { p.AddOp(TypeDiceSetMin) })?
             ('max' (number / sub) { p.AddOp(TypeDiceSetMax) })?

_dicePearMod <- '优势' { p.PushIntNumber("2"); p.AddOp(TypeDiceSetTimes); p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepHighNum) }
              / '劣势' { p.PushIntNumber("2"); p.AddOp(TypeDiceSetTimes); p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepLowNum) }

exprDice <- ((number / sub) { p.AddOp(TypeDiceInit); p.AddOp(TypeDiceSetTimes); p.LMark() } [dD] (number / sub)) _diceMod? _diceMod2 { p.AddOp(TypeDice) } sp // 3d20
          / [dD] { p.AddOp(TypeDiceInit); p.LMark() } (number / sub) (_dicePearMod / _diceMod)? _diceMod2 { p.AddOp(TypeDice) } sp  // d100
          / value

get_item <- ('[' sp exprRoot ']' sp (!'=') { p.AddOp(TypeGetItem) })*

array_call <- 'kh' { p.AddInvokeMethod("kh", 1) }
            / 'kl' { p.AddInvokeMethod("kl", 1) }
            / ('[' sp exprRoot ']' sp { p.AddOp(TypeGetItem) })+

get_attr <- ('.' sp identifier { p.WriteCode(TypeGetAttr, string(text)) })*

func_invoke <- '(' sp ')' sp { p.AddInvoke(0) }
             / '(' sp { p.CounterPush(); p.CounterAdd(1) } exprRoot (',' sp exprRoot {p.CounterAdd(1)} )* ')' sp { p.AddInvoke(p.CounterPop()) }

// 右值
value <- float
       / number
       / 'true' sp { p.PushIntNumber("1") }
       / 'false' sp { p.PushIntNumber("0") }
       / 'undefined' sp { p.PushUndefined() }
       / 'this' sp { p.PushThis() } get_item get_attr
       / '&' identifier { p.WriteCode(TypeLoadNameRaw, string(text)) } get_attr
       / identifier { p.AddLoadName(string(text)) } func_invoke? get_item get_attr
       / fstring
       / sub get_item get_attr
       / '[' sp ']' sp { p.PushArray(0) } array_call?
       / '[' sp { p.CounterPush(); p.CounterAdd(1) } exprRoot (',' sp exprRoot {p.CounterAdd(1)} )* ']' sp { p.PushArray(p.CounterPop()) } array_call?

// 数字
number <- < [0-9]+ > sp { p.PushIntNumber(string(text)) }
float <- < [0-9]* '.' [0-9]+ > sp { p.PushFloatNumber(string(text)) }

// 字符串
strPart <- < (escape / (![{`\\].))+ > { p.PushStr(string(text)); p.CounterAdd(1) }
strPart1 <- < (escape / (![{\36\\].))+ > { p.PushStr(string(text)); p.CounterAdd(1) }
strPart2 <- < (escape / (![{"\\\n\r].))+ > { p.PushStr(string(text)); p.CounterAdd(1) }
strPart3 <- < (escape / (![{\'\\\n\r].))+ > { p.PushStr(string(text)); p.CounterAdd(1) }

fstring <- (
        ('\'' '\'' { p.PushStr("") })
      / ('\36' '\36' { p.PushStr("") })
      / ('"' '"' { p.PushStr("") })
      / ('`' '`' { p.PushStr("") })
      / ('`' { p.CounterPush() } < ( ('{' sp exprRoot {p.CounterAdd(1)} '}') / ('{%' sp exprRoot {p.CounterAdd(1)} '%}') / strPart )* > '`' { p.AddFormatString(string(text), p.CounterPop()) })
      / ('\36' { p.CounterPush() } < ( ('{' sp exprRoot {p.CounterAdd(1)} '}') / ('{%' sp exprRoot {p.CounterAdd(1)} '%}') / strPart1 )* > '\36' { p.AddFormatString(string(text), p.CounterPop()) }) // 特殊标记 0x1E
      / ('"' { p.CounterPush() } < ( strPart2 )* > '"' { p.CounterPop() })
      / ('\'' { p.CounterPush() } < ( strPart3 )* > '\'' { p.CounterPop() } )
    ) sp

// 变量名
identifier <- !(('while' / 'if' / 'else' / 'continue' / 'break' / 'return' / 'func') (sp1 / [!"#%&\'()*+,-./:;<=>?@\[\\\]^`{|}~ \t\n\r\36])) < [^!"#%&\'()*+,-./:;<=>?@\[\\\]^`{|}~0-9 \t\n\r\36] [^!"#$%&\'()*+,-./;<=>?@\[\\\]^`{|}~ \t\n\r\36]* > sp // not (punctuation+number)

// 括号
sub <- parenOpen exprRoot parenClose
parenOpen <- '(' sp
parenClose <- ')' sp

// 加减乘除余 乘方
add <- ('+'/'＋') sp
minus <- ('-' / '－') sp
multiply <- ('*' / '＊') sp
divide <- ('/' / '／') sp
modulus <- '%' sp
exponentiation <- '^' sp / '**' sp

// 按位算符
bitwiseOr <- '|' sp
bitwiseAnd <- '&' sp

// 逻辑算符
logicOr <- '||' sp
logicAnd <- '&&' sp

// 比较算符
lt <- ('<' / '＜') sp
gt <- ('>' / '＞') sp
le <- ('<=' / '＜＝') sp
ge <- ('>=' / '＞＝') sp
eq <- ('==' / '＝＝') sp
ne <- ('!=' / '！＝') sp

// 其他
sp <- ( ' ' / '\t' / '\n' / '\r' / ('//' [^\n]*) )*
sp1 <- ( ' ' / '\t' / '\n' / '\r' / ('//' [^\n]*)) sp / !.
escape <- '\\' ([btnfr"'\\])  //  / OctalEscape / UnicodeEscape
