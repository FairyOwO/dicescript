//  Copyright 2022 fy <fy0748@gmail.com>
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package dicescript

type Parser Peg {
    ParserData
    Context
}

// 出口
dicescript <- stmtRoot { p.AddOp(TypeHalt) }
stmtRoot <- (stmtLines / ';' sp)+

stmtLines <- stmtWithBlock
           / stmtWithSemicolon (';' sp stmtWithSemicolon)*

stmtWithSemicolon <- stmtAssign / exprRoot

stmtWithBlock <- stmtIf

block <- ( '{' sp '}' / '{' sp stmtRoot '}' ) sp
stmtElse <- 'else' sp (block / stmtIf)
stmtIf <- 'if' sp exprRoot { p.AddOp(TypeJne); p.CodePushOffset() } block { p.AddOp(TypeJmp); p.CodePopSetOffset(); p.CodePushOffset(); }
           stmtElse? { p.CodePopSetOffset() }
// 'if' exprRoot block
// ('else' block)?

// if ... then .. else
// push 1
// jne 2
// push "ret1"
// jmp 1
// push "ret2"


stmtAssign <- identifier { p.NamePush(string(text)) } '=' sp exprRoot { p.AddStore(p.NamePop()) }

exprRoot <- exprTernary


// 三元算符 ? :
exprValueIfExists <- exprBitwise '?' sp { p.AddOp(TypeJne); p.CodePushOffset() } exprBitwise { p.AddOp(TypeJmp); p.CodePopSetOffset(); p.CodePushOffset(); } // 这里的Pop对应的是jne，所有jmp将攒到最后
exprTernary <- exprBitwise '?' sp { p.AddOp(TypeJne); p.CodePushOffset() } exprBitwise ':' sp { p.AddOp(TypeJmp); p.CodePopSetOffset(); p.CodePushOffset() } exprBitwise { p.CodePopSetOffset() }
        / exprValueIfExists { p.CounterPush() } ( ',' sp exprValueIfExists {p.CounterAdd(1)} )*  { p.PushStr(""); limit:=p.CounterPop()+1; for i:=int64(0); i<limit; i++ { p.CodePopSetOffset() } }
        / exprBitwise

// switch { case 1: ..., case 2: ... }
// push cond1
// jne 2
// push "ret1"
// jmp 5
// push cond2
// jne 2
// push "ret2"
// jmp 1
// push 0 // 默认
// push "ret3"


// 位运算
exprBitwise <- exprCompare ((logicOr / bitwiseOr) { p.LMark() } exprCompare { p.AddOp(TypeBitwiseOr) }
                 / (logicAnd / bitwiseAnd) { p.LMark() } exprCompare { p.AddOp(TypeBitwiseAnd) } )*


// 比较
exprCompare <- exprAdditive (
                 lt { p.LMark() } exprAdditive { p.AddOp(TypeCompLT) }
               / le { p.LMark() } exprAdditive { p.AddOp(TypeCompLE) }
               / eq { p.LMark() } exprAdditive { p.AddOp(TypeCompEQ) }
               / ne { p.LMark() } exprAdditive { p.AddOp(TypeCompNE) }
               / ge { p.LMark() } exprAdditive { p.AddOp(TypeCompGE) }
               / gt { p.LMark() } exprAdditive { p.AddOp(TypeCompGT) }
             )*

// 加减
exprAdditive <- exprMultiplicative (
                  add { p.LMark() } exprMultiplicative { p.AddOp(TypeAdd) }
                / minus { p.LMark() } exprMultiplicative { p.AddOp(TypeSubtract) }
              )*

// 乘除余
exprMultiplicative <- exprExp (
                        multiply { p.LMark() } exprExp { p.AddOp(TypeMultiply) }
                      / divide { p.LMark() } exprExp { p.AddOp(TypeDivide) }
                      / modulus { p.LMark() } exprExp { p.AddOp(TypeModulus) }
                    )*

// 平方
exprExp <- exprUnaryNeg (
             exponentiation { p.LMark() } exprUnaryNeg { p.AddOp(TypeExponentiation) }
         )*


// 正数 负数
exprUnaryNeg <- minus exprRoot { p.AddOp(TypeNegation) }
              / exprUnaryPos

exprUnaryPos <- add exprRoot { p.AddOp(TypePositive) }
              / exprDice

// 骰子算符，注: 越靠下的算符优先级越高
_diceMod <- (('kl' / [qQ]) (number / sub) { p.AddOp(TypeDiceSetKeepLowNum) } )  // 这里fvtt只有kl
          / (('kl' / [qQ]) { p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepLowNum) } )
          / (('kh' / [kK]) (number / sub) { p.AddOp(TypeDiceSetKeepHighNum) })  // 这里fvtt与国内骰一致
          / (('kh' / [kK]) { p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepHighNum) })
          / (('dh') (number / sub) { p.AddOp(TypeDiceSetDropHighNum) } ) // drop highest，需要在下一个之前，因为有2d20d1语法
          / (('dh') { p.PushIntNumber("1"); p.AddOp(TypeDiceSetDropHighNum) } )
          / (('dl') (number / sub) { p.AddOp(TypeDiceSetDropLowNum) } )  // drop lowest, 这里故意去掉了3d20d1 的支持，需要写成3d20dl1
          / (('dl') { p.PushIntNumber("1"); p.AddOp(TypeDiceSetDropLowNum) } )

_diceMod2 <- ('min' (number / sub) { p.AddOp(TypeDiceSetMin) })?
             ('max' (number / sub) { p.AddOp(TypeDiceSetMax) })?

_dicePearMod <- '优势' { p.PushIntNumber("2"); p.AddOp(TypeDiceSetTimes); p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepHighNum) }
              / '劣势' { p.PushIntNumber("2"); p.AddOp(TypeDiceSetTimes); p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepLowNum) }

exprDice <- ((number / sub) { p.AddOp(TypeDiceInit); p.AddOp(TypeDiceSetTimes); p.LMark() } [dD] (number / sub)) _diceMod? _diceMod2 { p.AddOp(TypeDice) } sp // 3d20
          / [dD] { p.AddOp(TypeDiceInit); p.LMark() } (number / sub) (_dicePearMod / _diceMod)? _diceMod2 { p.AddOp(TypeDice) } sp  // d100
          / value

// 右值
value <- float
       / number
       / identifier { p.AddLoadName(string(text)) }
       / fstring
       / sub

// 数字
number <- < [0-9]+ > sp { p.PushIntNumber(string(text)) }
float <- < [0-9]* '.' [0-9]+ > sp { p.PushFloatNumber(string(text)) }

// 字符串
strPart <- < (escape / (![{`\\].))+ > { p.PushStr(string(text)); p.CounterAdd(1) }
strPart1 <- < (escape / (![{\36\\].))+ > { p.PushStr(string(text)); p.CounterAdd(1) }
strPart2 <- < (escape / (![{"\\\n\r].))+ > { p.PushStr(string(text)); p.CounterAdd(1) }
strPart3 <- < (escape / (![{\'\\\n\r].))+ > { p.PushStr(string(text)); p.CounterAdd(1) }

fstring <- (
        ('\'' '\'' { p.PushStr("") })
      / ('\36' '\36' { p.PushStr("") })
      / ('"' '"' { p.PushStr("") })
      / ('`' '`' { p.PushStr("") })
      / ('`' { p.CounterPush() } < ( ('{' sp exprRoot {p.CounterAdd(1)} '}') / ('{%' sp exprRoot {p.CounterAdd(1)} '%}') / strPart )* > '`' { p.AddFormatString(string(text), p.CounterPop()) })
      / ('\36' { p.CounterPush() } < ( ('{' sp exprRoot {p.CounterAdd(1)} '}') / ('{%' sp exprRoot {p.CounterAdd(1)} '%}') / strPart1 )* > '\36' { p.AddFormatString(string(text), p.CounterPop()) }) // 特殊标记 0x1E
      / ('"' { p.CounterPush() } < ( strPart2 )* > '"' { p.CounterPop() })
      / ('\'' { p.CounterPush() } < ( strPart3 )* > '\'' { p.CounterPop() } )
    ) sp

// 变量名
// TODO: 排除掉关键字
identifier <- < [^!"#%&\'()*+,-./:;<=>?@\[\\\]^`{|}~0-9 \t\n\r\36] [^!"#$%&\'()*+,-./;<=>?@\[\\\]^`{|}~ \t\n\r\36]* > sp // not (punctuation+number)

// 括号
sub <- parenOpen exprRoot parenClose
parenOpen <- '(' sp
parenClose <- ')' sp

// 加减乘除余 乘方
add <- ('+'/'＋') sp
minus <- ('-' / '－') sp
multiply <- ('*' / '＊') sp
divide <- ('/' / '／') sp
modulus <- '%' sp
exponentiation <- '^' sp / '**' sp

// 按位算符
bitwiseOr <- '|' sp
bitwiseAnd <- '&' sp

// 逻辑算符
logicOr <- '||' sp
logicAnd <- '&&' sp

// 比较算符
lt <- ('<' / '＜') sp
gt <- ('>' / '＞') sp
le <- ('<=' / '＜＝') sp
ge <- ('>=' / '＞＝') sp
eq <- ('==' / '＝＝') sp
ne <- ('!=' / '！＝') sp

// 其他
sp <- ( ' ' / '\t' / '\n' / '\r' / ('//' [^\n]*) )*
escape <- '\\' ([btnfr"'\\])  //  / OctalEscape / UnicodeEscape
