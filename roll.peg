//  Copyright 2022 fy <fy0748@gmail.com>
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package dicescript

type Parser Peg {
    Context
}

// 出口
stmtRoot <- exprBitwise { p.AddOp(TypeHalt) }

exprRoot <- exprBitwise

// 位运算
exprBitwise <- exprCompare ((logicOr / bitwiseOr) { p.LMark() } exprCompare { p.AddOp(TypeBitwiseOr) }
                 / (logicAnd / bitwiseAnd) { p.LMark() } exprCompare { p.AddOp(TypeBitwiseAnd) } )*


// 比较
exprCompare <- exprAdditive (
                 lt { p.LMark() } exprAdditive { p.AddOp(TypeCompLT) }
               / le { p.LMark() } exprAdditive { p.AddOp(TypeCompLE) }
               / eq { p.LMark() } exprAdditive { p.AddOp(TypeCompEQ) }
               / ne { p.LMark() } exprAdditive { p.AddOp(TypeCompNE) }
               / ge { p.LMark() } exprAdditive { p.AddOp(TypeCompGE) }
               / gt { p.LMark() } exprAdditive { p.AddOp(TypeCompGT) }
             )*

// 加减
exprAdditive <- exprMultiplicative (
                  add { p.LMark() } exprMultiplicative { p.AddOp(TypeAdd) }
                / minus { p.LMark() } exprMultiplicative { p.AddOp(TypeSubtract) }
              )*

// 乘除余
exprMultiplicative <- exprExp (
                        multiply { p.LMark() } exprExp { p.AddOp(TypeMultiply) }
                      / divide { p.LMark() } exprExp { p.AddOp(TypeDivide) }
                      / modulus { p.LMark() } exprExp { p.AddOp(TypeModulus) }
                    )*

// 平方
exprExp <- exprUnaryNeg (
             exponentiation { p.LMark() } exprUnaryNeg { p.AddOp(TypeExponentiation) }
         )*


// 正数 负数
exprUnaryNeg <- minus exprUnaryPos
              / exprUnaryPos

exprUnaryPos <- add exprDice
              / exprDice

// 骰子算符，注: 越靠下的优先级越高
_diceMod <- (([kK] / 'kh') (number / sub) { p.AddOp(TypeDiceSetKeepHighNum) })  // 这里fvtt与国内骰一致
          / (([kK] / 'kh') { p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepHighNum) })
          / (([qQ] / 'kl') (number / sub) { p.AddOp(TypeDiceSetKeepLowNum) } )  // 这里fvtt只有kl
          / (([qQ] / 'kl') { p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepLowNum) } )
          / ('dh' (number / sub) { p.AddOp(TypeDiceSetDropHighNum) } ) // drop highest，需要在下一个之前，因为有2d20d1语法
          / (([dD] / 'dl') (number / sub) { p.AddOp(TypeDiceSetDropLowNum) } )  // drop lowest
          / (([dD] / 'dl') { p.PushIntNumber("1"); p.AddOp(TypeDiceSetDropLowNum) } )

_diceMod2 <- ('min' (number / sub) { p.AddOp(TypeDiceSetMin) })?
             ('max' (number / sub) { p.AddOp(TypeDiceSetMax) })?

_dicePearMod <- '优势' { p.PushIntNumber("2"); p.AddOp(TypeDiceSetTimes); p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepHighNum) }
              / '劣势' { p.PushIntNumber("2"); p.AddOp(TypeDiceSetTimes); p.PushIntNumber("1"); p.AddOp(TypeDiceSetKeepLowNum) }

exprDice <- ((number / sub) { p.AddOp(TypeDiceInit); p.AddOp(TypeDiceSetTimes); p.LMark() } [dD] (number / sub)) _diceMod? _diceMod2 { p.AddOp(TypeDice) } sp // 3d20
          / [dD] { p.AddOp(TypeDiceInit); p.LMark() } (number / sub) (_dicePearMod / _diceMod)? _diceMod2 { p.AddOp(TypeDice) } sp  // d100
          / value

// 右值
value <- float
       / number
       / identifier { p.AddLoadName(string(text)) }
       / sub

// 数字
number <- < [0-9]+ > sp { p.PushIntNumber(string(text)) }
float <- < [0-9]* '.' [0-9]+ > sp { p.PushFloatNumber(string(text)) }

// 变量名
identifier <- < [^!"#%&\'()*+,-./:;<=>?@\[\\\]^`{|}~0-9 \t\n\r\36] [^!"#$%&\'()*+,-./;<=>?@\[\\\]^`{|}~ \t\n\r\36]* > sp // not (punctuation+number)

// 括号
sub <- parenOpen exprRoot parenClose
parenOpen <- '(' sp
parenClose <- ')' sp

// 加减乘除余 乘方
add <- ('+'/'＋') sp
minus <- ('-' / '－') sp
multiply <- ('*' / '＊') sp
divide <- ('/' / '／') sp
modulus <- '%' sp
exponentiation <- '^' sp / '**' sp

// 按位算符
bitwiseOr <- '|' sp
bitwiseAnd <- '&' sp

// 逻辑算符
logicOr <- '||' sp
logicAnd <- '&&' sp

// 比较算符
lt <- ('<' / '＜') sp
gt <- ('>' / '＞') sp
le <- ('<=' / '＜＝') sp
ge <- ('>=' / '＞＝') sp
eq <- ('==' / '＝＝') sp
ne <- ('!=' / '！＝') sp

// 其他
sp <- ( ' ' / '\t' / '\n' / '\r' / ('//' [^\n]*) )*
escape <- '\\' ([btnfr"'\\])  //  / OctalEscape / UnicodeEscape
