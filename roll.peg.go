// Code generated by pigeon; DO NOT EDIT.

//nolint:unreachable
package dicescript

import (
	"bytes"
	"errors"
	"fmt"
	"math"
	"sort"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

type ParserCustomData struct {
	ParserData
	Config RollConfig
}

func toStr(x []byte) string {
	return string(x)
}

var g = &grammar{
	rules: []*rule{
		{
			name: "dicescript",
			pos:  position{line: 31, col: 1, offset: 787},
			expr: &actionExpr{
				pos: position{line: 31, col: 15, offset: 801},
				run: (*parser).callondicescript1,
				expr: &seqExpr{
					pos: position{line: 31, col: 15, offset: 801},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 31, col: 15, offset: 801},
							name: "sp",
						},
						&ruleRefExpr{
							pos:  position{line: 31, col: 18, offset: 804},
							name: "stmtRoot",
						},
						&ruleRefExpr{
							pos:  position{line: 31, col: 27, offset: 813},
							name: "sp",
						},
					},
				},
			},
		},
		{
			name: "stmtRoot",
			pos:  position{line: 36, col: 1, offset: 863},
			expr: &seqExpr{
				pos: position{line: 36, col: 13, offset: 875},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 36, col: 13, offset: 875},
						name: "stmtLines",
					},
					&ruleRefExpr{
						pos:  position{line: 36, col: 23, offset: 885},
						name: "sp",
					},
				},
			},
		},
		{
			name: "stmtLines",
			pos:  position{line: 38, col: 1, offset: 889},
			expr: &choiceExpr{
				pos: position{line: 38, col: 14, offset: 902},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 38, col: 14, offset: 902},
						exprs: []any{
							&andCodeExpr{
								pos: position{line: 38, col: 14, offset: 902},
								run: (*parser).callonstmtLines3,
							},
							&ruleRefExpr{
								pos:  position{line: 38, col: 52, offset: 940},
								name: "stmtWithBlock",
							},
							&zeroOrOneExpr{
								pos: position{line: 38, col: 66, offset: 954},
								expr: &ruleRefExpr{
									pos:  position{line: 38, col: 66, offset: 954},
									name: "stmtLines",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 39, col: 14, offset: 978},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 39, col: 14, offset: 978},
								name: "flagsSwitch",
							},
							&zeroOrOneExpr{
								pos: position{line: 39, col: 26, offset: 990},
								expr: &ruleRefExpr{
									pos:  position{line: 39, col: 26, offset: 990},
									name: "stmtLines",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 40, col: 14, offset: 1014},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 40, col: 14, offset: 1014},
								name: "comment",
							},
							&ruleRefExpr{
								pos:  position{line: 40, col: 22, offset: 1022},
								name: "sp",
							},
							&zeroOrOneExpr{
								pos: position{line: 40, col: 25, offset: 1025},
								expr: &ruleRefExpr{
									pos:  position{line: 40, col: 25, offset: 1025},
									name: "stmtLines",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 41, col: 14, offset: 1049},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 41, col: 14, offset: 1049},
								name: "stmtWithSemicolon",
							},
							&zeroOrOneExpr{
								pos: position{line: 41, col: 32, offset: 1067},
								expr: &ruleRefExpr{
									pos:  position{line: 41, col: 32, offset: 1067},
									name: "nextLine",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 42, col: 14, offset: 1090},
						exprs: []any{
							&oneOrMoreExpr{
								pos: position{line: 42, col: 14, offset: 1090},
								expr: &seqExpr{
									pos: position{line: 42, col: 15, offset: 1091},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 42, col: 15, offset: 1091},
											val:        ";",
											ignoreCase: false,
											want:       "\";\"",
										},
										&ruleRefExpr{
											pos:  position{line: 42, col: 19, offset: 1095},
											name: "sp",
										},
									},
								},
							},
							&zeroOrOneExpr{
								pos: position{line: 42, col: 24, offset: 1100},
								expr: &ruleRefExpr{
									pos:  position{line: 42, col: 24, offset: 1100},
									name: "stmtLines",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "flagsSwitch",
			pos:  position{line: 44, col: 1, offset: 1112},
			expr: &actionExpr{
				pos: position{line: 44, col: 16, offset: 1127},
				run: (*parser).callonflagsSwitch1,
				expr: &seqExpr{
					pos: position{line: 44, col: 16, offset: 1127},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 44, col: 16, offset: 1127},
							val:        "//",
							ignoreCase: false,
							want:       "\"//\"",
						},
						&ruleRefExpr{
							pos:  position{line: 44, col: 21, offset: 1132},
							name: "sp",
						},
						&litMatcher{
							pos:        position{line: 44, col: 24, offset: 1135},
							val:        "#EnableDice",
							ignoreCase: false,
							want:       "\"#EnableDice\"",
						},
						&ruleRefExpr{
							pos:  position{line: 44, col: 38, offset: 1149},
							name: "sp1x",
						},
						&labeledExpr{
							pos:   position{line: 44, col: 43, offset: 1154},
							label: "id",
							expr: &ruleRefExpr{
								pos:  position{line: 44, col: 46, offset: 1157},
								name: "identifier",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 44, col: 57, offset: 1168},
							name: "sp1x",
						},
						&labeledExpr{
							pos:   position{line: 44, col: 62, offset: 1173},
							label: "on",
							expr: &choiceExpr{
								pos: position{line: 44, col: 67, offset: 1178},
								alternatives: []any{
									&litMatcher{
										pos:        position{line: 44, col: 67, offset: 1178},
										val:        "true",
										ignoreCase: false,
										want:       "\"true\"",
									},
									&litMatcher{
										pos:        position{line: 44, col: 76, offset: 1187},
										val:        "false",
										ignoreCase: false,
										want:       "\"false\"",
									},
								},
							},
							textCapture: true,
						},
						&ruleRefExpr{
							pos:  position{line: 44, col: 86, offset: 1197},
							name: "commentLineRest",
						},
					},
				},
			},
		},
		{
			name: "stmtWithSemicolon",
			pos:  position{line: 58, col: 1, offset: 1538},
			expr: &choiceExpr{
				pos: position{line: 58, col: 22, offset: 1559},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 58, col: 22, offset: 1559},
						name: "stmtAssign",
					},
					&ruleRefExpr{
						pos:  position{line: 58, col: 35, offset: 1572},
						name: "stmtBreak",
					},
					&ruleRefExpr{
						pos:  position{line: 58, col: 47, offset: 1584},
						name: "stmtContinue",
					},
					&ruleRefExpr{
						pos:  position{line: 58, col: 62, offset: 1599},
						name: "exprRoot",
					},
				},
			},
		},
		{
			name: "stmtWithBlock",
			pos:  position{line: 60, col: 1, offset: 1609},
			expr: &choiceExpr{
				pos: position{line: 60, col: 18, offset: 1626},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 60, col: 18, offset: 1626},
						name: "stmtIf",
					},
					&ruleRefExpr{
						pos:  position{line: 60, col: 27, offset: 1635},
						name: "stmtFunc",
					},
					&ruleRefExpr{
						pos:  position{line: 60, col: 38, offset: 1646},
						name: "stmtWhile",
					},
					&ruleRefExpr{
						pos:  position{line: 60, col: 50, offset: 1658},
						name: "stmtReturn",
					},
				},
			},
		},
		{
			name: "nextLine",
			pos:  position{line: 62, col: 1, offset: 1670},
			expr: &seqExpr{
				pos: position{line: 62, col: 13, offset: 1682},
				exprs: []any{
					&oneOrMoreExpr{
						pos: position{line: 62, col: 13, offset: 1682},
						expr: &seqExpr{
							pos: position{line: 62, col: 14, offset: 1683},
							exprs: []any{
								&choiceExpr{
									pos: position{line: 62, col: 15, offset: 1684},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 62, col: 15, offset: 1684},
											exprs: []any{
												&ruleRefExpr{
													pos:  position{line: 62, col: 15, offset: 1684},
													name: "spNoCR",
												},
												&litMatcher{
													pos:        position{line: 62, col: 22, offset: 1691},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&seqExpr{
											pos: position{line: 62, col: 29, offset: 1698},
											exprs: []any{
												&ruleRefExpr{
													pos:  position{line: 62, col: 29, offset: 1698},
													name: "sp",
												},
												&litMatcher{
													pos:        position{line: 62, col: 32, offset: 1701},
													val:        ";",
													ignoreCase: false,
													want:       "\";\"",
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 62, col: 37, offset: 1706},
									name: "sp",
								},
							},
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 62, col: 42, offset: 1711},
						expr: &ruleRefExpr{
							pos:  position{line: 62, col: 42, offset: 1711},
							name: "stmtLines",
						},
					},
				},
			},
		},
		{
			name: "stmtBreak",
			pos:  position{line: 64, col: 1, offset: 1723},
			expr: &actionExpr{
				pos: position{line: 64, col: 14, offset: 1736},
				run: (*parser).callonstmtBreak1,
				expr: &seqExpr{
					pos: position{line: 64, col: 14, offset: 1736},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 64, col: 14, offset: 1736},
							val:        "break",
							ignoreCase: false,
							want:       "\"break\"",
						},
						&ruleRefExpr{
							pos:  position{line: 64, col: 22, offset: 1744},
							name: "sp",
						},
					},
				},
			},
		},
		{
			name: "stmtContinue",
			pos:  position{line: 72, col: 1, offset: 1883},
			expr: &actionExpr{
				pos: position{line: 72, col: 17, offset: 1899},
				run: (*parser).callonstmtContinue1,
				expr: &seqExpr{
					pos: position{line: 72, col: 17, offset: 1899},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 72, col: 17, offset: 1899},
							val:        "continue",
							ignoreCase: false,
							want:       "\"continue\"",
						},
						&ruleRefExpr{
							pos:  position{line: 72, col: 28, offset: 1910},
							name: "sp",
						},
					},
				},
			},
		},
		{
			name: "stmtReturn",
			pos:  position{line: 80, col: 1, offset: 2055},
			expr: &choiceExpr{
				pos: position{line: 80, col: 15, offset: 2069},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 80, col: 15, offset: 2069},
						run: (*parser).callonstmtReturn2,
						expr: &seqExpr{
							pos: position{line: 80, col: 15, offset: 2069},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 80, col: 15, offset: 2069},
									val:        "return",
									ignoreCase: false,
									want:       "\"return\"",
								},
								&ruleRefExpr{
									pos:  position{line: 80, col: 24, offset: 2078},
									name: "sp1x",
								},
								&ruleRefExpr{
									pos:  position{line: 80, col: 29, offset: 2083},
									name: "exprRoot",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 81, col: 15, offset: 2136},
						run: (*parser).callonstmtReturn7,
						expr: &seqExpr{
							pos: position{line: 81, col: 15, offset: 2136},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 81, col: 15, offset: 2136},
									val:        "return",
									ignoreCase: false,
									want:       "\"return\"",
								},
								&ruleRefExpr{
									pos:  position{line: 81, col: 24, offset: 2145},
									name: "sp",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "stmtWhile",
			pos:  position{line: 83, col: 1, offset: 2203},
			expr: &seqExpr{
				pos: position{line: 83, col: 14, offset: 2216},
				exprs: []any{
					&actionExpr{
						pos: position{line: 83, col: 14, offset: 2216},
						run: (*parser).callonstmtWhile2,
						expr: &litMatcher{
							pos:        position{line: 83, col: 14, offset: 2216},
							val:        "while",
							ignoreCase: false,
							want:       "\"while\"",
						},
					},
					&actionExpr{
						pos: position{line: 83, col: 66, offset: 2268},
						run: (*parser).callonstmtWhile4,
						expr: &seqExpr{
							pos: position{line: 83, col: 66, offset: 2268},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 83, col: 66, offset: 2268},
									name: "sp1x",
								},
								&ruleRefExpr{
									pos:  position{line: 83, col: 71, offset: 2273},
									name: "exprRoot",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 84, col: 14, offset: 2342},
						run: (*parser).callonstmtWhile8,
						expr: &ruleRefExpr{
							pos:  position{line: 84, col: 14, offset: 2342},
							name: "block",
						},
					},
				},
			},
		},
		{
			name: "block",
			pos:  position{line: 90, col: 1, offset: 2639},
			expr: &seqExpr{
				pos: position{line: 90, col: 10, offset: 2648},
				exprs: []any{
					&choiceExpr{
						pos: position{line: 90, col: 12, offset: 2650},
						alternatives: []any{
							&seqExpr{
								pos: position{line: 90, col: 12, offset: 2650},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 90, col: 12, offset: 2650},
										val:        "{",
										ignoreCase: false,
										want:       "\"{\"",
									},
									&ruleRefExpr{
										pos:  position{line: 90, col: 16, offset: 2654},
										name: "sp",
									},
									&litMatcher{
										pos:        position{line: 90, col: 19, offset: 2657},
										val:        "}",
										ignoreCase: false,
										want:       "\"}\"",
									},
								},
							},
							&seqExpr{
								pos: position{line: 90, col: 25, offset: 2663},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 90, col: 25, offset: 2663},
										val:        "{",
										ignoreCase: false,
										want:       "\"{\"",
									},
									&ruleRefExpr{
										pos:  position{line: 90, col: 29, offset: 2667},
										name: "sp",
									},
									&ruleRefExpr{
										pos:  position{line: 90, col: 32, offset: 2670},
										name: "stmtRoot",
									},
									&litMatcher{
										pos:        position{line: 90, col: 41, offset: 2679},
										val:        "}",
										ignoreCase: false,
										want:       "\"}\"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 90, col: 47, offset: 2685},
						name: "sp",
					},
				},
			},
		},
		{
			name: "stmtElse",
			pos:  position{line: 91, col: 1, offset: 2688},
			expr: &seqExpr{
				pos: position{line: 91, col: 13, offset: 2700},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 91, col: 13, offset: 2700},
						val:        "else",
						ignoreCase: false,
						want:       "\"else\"",
					},
					&choiceExpr{
						pos: position{line: 91, col: 21, offset: 2708},
						alternatives: []any{
							&seqExpr{
								pos: position{line: 91, col: 21, offset: 2708},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 91, col: 21, offset: 2708},
										name: "sp",
									},
									&ruleRefExpr{
										pos:  position{line: 91, col: 24, offset: 2711},
										name: "block",
									},
								},
							},
							&seqExpr{
								pos: position{line: 91, col: 32, offset: 2719},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 91, col: 32, offset: 2719},
										name: "sp1x",
									},
									&ruleRefExpr{
										pos:  position{line: 91, col: 37, offset: 2724},
										name: "stmtIf",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "stmtIf",
			pos:  position{line: 92, col: 1, offset: 2732},
			expr: &seqExpr{
				pos: position{line: 92, col: 11, offset: 2742},
				exprs: []any{
					&actionExpr{
						pos: position{line: 92, col: 11, offset: 2742},
						run: (*parser).callonstmtIf2,
						expr: &seqExpr{
							pos: position{line: 92, col: 11, offset: 2742},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 92, col: 11, offset: 2742},
									val:        "if",
									ignoreCase: false,
									want:       "\"if\"",
								},
								&ruleRefExpr{
									pos:  position{line: 92, col: 16, offset: 2747},
									name: "sp1x",
								},
								&ruleRefExpr{
									pos:  position{line: 92, col: 21, offset: 2752},
									name: "exprRoot",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 92, col: 77, offset: 2808},
						run: (*parser).callonstmtIf7,
						expr: &ruleRefExpr{
							pos:  position{line: 92, col: 77, offset: 2808},
							name: "block",
						},
					},
					&actionExpr{
						pos: position{line: 93, col: 12, offset: 2899},
						run: (*parser).callonstmtIf9,
						expr: &zeroOrOneExpr{
							pos: position{line: 93, col: 12, offset: 2899},
							expr: &ruleRefExpr{
								pos:  position{line: 93, col: 12, offset: 2899},
								name: "stmtElse",
							},
						},
					},
				},
			},
		},
		{
			name: "func_def_params",
			pos:  position{line: 106, col: 1, offset: 3081},
			expr: &choiceExpr{
				pos: position{line: 106, col: 20, offset: 3100},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 106, col: 20, offset: 3100},
						run: (*parser).callonfunc_def_params2,
						expr: &seqExpr{
							pos: position{line: 106, col: 20, offset: 3100},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 106, col: 20, offset: 3100},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&ruleRefExpr{
									pos:  position{line: 106, col: 24, offset: 3104},
									name: "sp",
								},
								&litMatcher{
									pos:        position{line: 106, col: 27, offset: 3107},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
								&ruleRefExpr{
									pos:  position{line: 106, col: 31, offset: 3111},
									name: "sp",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 107, col: 20, offset: 3158},
						exprs: []any{
							&actionExpr{
								pos: position{line: 107, col: 20, offset: 3158},
								run: (*parser).callonfunc_def_params9,
								expr: &seqExpr{
									pos: position{line: 107, col: 20, offset: 3158},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 107, col: 20, offset: 3158},
											val:        "(",
											ignoreCase: false,
											want:       "\"(\"",
										},
										&ruleRefExpr{
											pos:  position{line: 107, col: 24, offset: 3162},
											name: "sp",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 107, col: 74, offset: 3212},
								run: (*parser).callonfunc_def_params13,
								expr: &seqExpr{
									pos: position{line: 107, col: 74, offset: 3212},
									exprs: []any{
										&labeledExpr{
											pos:   position{line: 107, col: 74, offset: 3212},
											label: "id",
											expr: &ruleRefExpr{
												pos:  position{line: 107, col: 77, offset: 3215},
												name: "identifier",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 107, col: 88, offset: 3226},
											name: "sp",
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 107, col: 124, offset: 3262},
								exprs: []any{
									&zeroOrMoreExpr{
										pos: position{line: 107, col: 124, offset: 3262},
										expr: &seqExpr{
											pos: position{line: 107, col: 125, offset: 3263},
											exprs: []any{
												&actionExpr{
													pos: position{line: 107, col: 125, offset: 3263},
													run: (*parser).callonfunc_def_params21,
													expr: &seqExpr{
														pos: position{line: 107, col: 125, offset: 3263},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 107, col: 125, offset: 3263},
																val:        ",",
																ignoreCase: false,
																want:       "\",\"",
															},
															&ruleRefExpr{
																pos:  position{line: 107, col: 129, offset: 3267},
																name: "sp",
															},
															&labeledExpr{
																pos:   position{line: 107, col: 132, offset: 3270},
																label: "id2",
																expr: &ruleRefExpr{
																	pos:  position{line: 107, col: 136, offset: 3274},
																	name: "identifier",
																},
															},
															&ruleRefExpr{
																pos:  position{line: 107, col: 147, offset: 3285},
																name: "sp",
															},
														},
													},
												},
												&codeExpr{
													pos: position{line: 107, col: 184, offset: 3322},
													run: (*parser).callonfunc_def_params28,
												},
											},
										},
									},
									&litMatcher{
										pos:        position{line: 107, col: 210, offset: 3348},
										val:        ")",
										ignoreCase: false,
										want:       "\")\"",
									},
									&ruleRefExpr{
										pos:  position{line: 107, col: 214, offset: 3352},
										name: "sp",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "stmtFunc",
			pos:  position{line: 109, col: 1, offset: 3356},
			expr: &seqExpr{
				pos: position{line: 109, col: 13, offset: 3368},
				exprs: []any{
					&actionExpr{
						pos: position{line: 109, col: 13, offset: 3368},
						run: (*parser).callonstmtFunc2,
						expr: &seqExpr{
							pos: position{line: 109, col: 13, offset: 3368},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 109, col: 13, offset: 3368},
									val:        "func",
									ignoreCase: false,
									want:       "\"func\"",
								},
								&ruleRefExpr{
									pos:  position{line: 109, col: 20, offset: 3375},
									name: "sp1x",
								},
								&labeledExpr{
									pos:   position{line: 109, col: 25, offset: 3380},
									label: "id",
									expr: &ruleRefExpr{
										pos:  position{line: 109, col: 28, offset: 3383},
										name: "identifier",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 109, col: 39, offset: 3394},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 109, col: 75, offset: 3430},
						run: (*parser).callonstmtFunc9,
						expr: &seqExpr{
							pos: position{line: 109, col: 75, offset: 3430},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 109, col: 75, offset: 3430},
									name: "func_def_params",
								},
								&litMatcher{
									pos:        position{line: 109, col: 91, offset: 3446},
									val:        "{",
									ignoreCase: false,
									want:       "\"{\"",
								},
								&ruleRefExpr{
									pos:  position{line: 109, col: 95, offset: 3450},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 109, col: 120, offset: 3475},
						run: (*parser).callonstmtFunc14,
						expr: &seqExpr{
							pos: position{line: 109, col: 120, offset: 3475},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 109, col: 120, offset: 3475},
									label: "exprText",
									expr: &zeroOrOneExpr{
										pos: position{line: 109, col: 131, offset: 3486},
										expr: &ruleRefExpr{
											pos:  position{line: 109, col: 131, offset: 3486},
											name: "stmtRoot",
										},
									},
									textCapture: true,
								},
								&litMatcher{
									pos:        position{line: 109, col: 143, offset: 3498},
									val:        "}",
									ignoreCase: false,
									want:       "\"}\"",
								},
								&ruleRefExpr{
									pos:  position{line: 109, col: 147, offset: 3502},
									name: "sp",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "stmtAssignType1",
			pos:  position{line: 113, col: 1, offset: 3717},
			expr: &seqExpr{
				pos: position{line: 113, col: 20, offset: 3736},
				exprs: []any{
					&actionExpr{
						pos: position{line: 113, col: 20, offset: 3736},
						run: (*parser).callonstmtAssignType12,
						expr: &seqExpr{
							pos: position{line: 113, col: 20, offset: 3736},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 113, col: 20, offset: 3736},
									label: "id",
									expr: &ruleRefExpr{
										pos:  position{line: 113, col: 23, offset: 3739},
										name: "identifier",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 113, col: 34, offset: 3750},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 113, col: 70, offset: 3786},
						run: (*parser).callonstmtAssignType17,
						expr: &seqExpr{
							pos: position{line: 113, col: 70, offset: 3786},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 113, col: 70, offset: 3786},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&ruleRefExpr{
									pos:  position{line: 113, col: 74, offset: 3790},
									name: "sp",
								},
								&ruleRefExpr{
									pos:  position{line: 113, col: 77, offset: 3793},
									name: "exprRoot",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "stmtAssignType2",
			pos:  position{line: 114, col: 1, offset: 3840},
			expr: &seqExpr{
				pos: position{line: 114, col: 20, offset: 3859},
				exprs: []any{
					&actionExpr{
						pos: position{line: 114, col: 20, offset: 3859},
						run: (*parser).callonstmtAssignType22,
						expr: &seqExpr{
							pos: position{line: 114, col: 20, offset: 3859},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 114, col: 20, offset: 3859},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 114, col: 24, offset: 3863},
									label: "id",
									expr: &ruleRefExpr{
										pos:  position{line: 114, col: 27, offset: 3866},
										name: "identifier",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 114, col: 38, offset: 3877},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 114, col: 74, offset: 3913},
						run: (*parser).callonstmtAssignType28,
						expr: &seqExpr{
							pos: position{line: 114, col: 74, offset: 3913},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 114, col: 74, offset: 3913},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&ruleRefExpr{
									pos:  position{line: 114, col: 78, offset: 3917},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 114, col: 103, offset: 3942},
						run: (*parser).callonstmtAssignType212,
						expr: &labeledExpr{
							pos:   position{line: 114, col: 103, offset: 3942},
							label: "expr",
							expr: &ruleRefExpr{
								pos:  position{line: 114, col: 109, offset: 3948},
								name: "exprRoot",
							},
							textCapture: true,
						},
					},
				},
			},
		},
		{
			name: "stmtAssignType3",
			pos:  position{line: 115, col: 1, offset: 4019},
			expr: &seqExpr{
				pos: position{line: 115, col: 20, offset: 4038},
				exprs: []any{
					&actionExpr{
						pos: position{line: 115, col: 20, offset: 4038},
						run: (*parser).callonstmtAssignType32,
						expr: &seqExpr{
							pos: position{line: 115, col: 20, offset: 4038},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 115, col: 20, offset: 4038},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 115, col: 24, offset: 4042},
									label: "id",
									expr: &ruleRefExpr{
										pos:  position{line: 115, col: 27, offset: 4045},
										name: "identifier",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 115, col: 38, offset: 4056},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 115, col: 74, offset: 4092},
						run: (*parser).callonstmtAssignType38,
						expr: &seqExpr{
							pos: position{line: 115, col: 74, offset: 4092},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 115, col: 74, offset: 4092},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 115, col: 78, offset: 4096},
									label: "id2",
									expr: &ruleRefExpr{
										pos:  position{line: 115, col: 82, offset: 4100},
										name: "identifier",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 115, col: 93, offset: 4111},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 115, col: 130, offset: 4148},
						run: (*parser).callonstmtAssignType314,
						expr: &seqExpr{
							pos: position{line: 115, col: 130, offset: 4148},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 115, col: 130, offset: 4148},
									name: "sp",
								},
								&litMatcher{
									pos:        position{line: 115, col: 133, offset: 4151},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&ruleRefExpr{
									pos:  position{line: 115, col: 137, offset: 4155},
									name: "sp",
								},
								&ruleRefExpr{
									pos:  position{line: 115, col: 140, offset: 4158},
									name: "exprRoot",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "stmtAssignType4",
			pos:  position{line: 116, col: 1, offset: 4263},
			expr: &seqExpr{
				pos: position{line: 116, col: 20, offset: 4282},
				exprs: []any{
					&actionExpr{
						pos: position{line: 116, col: 20, offset: 4282},
						run: (*parser).callonstmtAssignType42,
						expr: &seqExpr{
							pos: position{line: 116, col: 20, offset: 4282},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 116, col: 20, offset: 4282},
									val:        "this",
									ignoreCase: false,
									want:       "\"this\"",
								},
								&ruleRefExpr{
									pos:  position{line: 116, col: 27, offset: 4289},
									name: "sp",
								},
								&litMatcher{
									pos:        position{line: 116, col: 30, offset: 4292},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&ruleRefExpr{
									pos:  position{line: 116, col: 34, offset: 4296},
									name: "sp",
								},
								&labeledExpr{
									pos:   position{line: 116, col: 37, offset: 4299},
									label: "id",
									expr: &ruleRefExpr{
										pos:  position{line: 116, col: 40, offset: 4302},
										name: "identifier",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 116, col: 51, offset: 4313},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 116, col: 87, offset: 4349},
						run: (*parser).callonstmtAssignType411,
						expr: &seqExpr{
							pos: position{line: 116, col: 87, offset: 4349},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 116, col: 87, offset: 4349},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&ruleRefExpr{
									pos:  position{line: 116, col: 91, offset: 4353},
									name: "sp",
								},
								&ruleRefExpr{
									pos:  position{line: 116, col: 94, offset: 4356},
									name: "exprRoot",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "stmtAssignType5",
			pos:  position{line: 117, col: 1, offset: 4408},
			expr: &seqExpr{
				pos: position{line: 117, col: 20, offset: 4427},
				exprs: []any{
					&actionExpr{
						pos: position{line: 117, col: 20, offset: 4427},
						run: (*parser).callonstmtAssignType52,
						expr: &seqExpr{
							pos: position{line: 117, col: 20, offset: 4427},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 117, col: 20, offset: 4427},
									label: "id",
									expr: &ruleRefExpr{
										pos:  position{line: 117, col: 23, offset: 4430},
										name: "identifier",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 117, col: 34, offset: 4441},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 117, col: 70, offset: 4477},
						run: (*parser).callonstmtAssignType57,
						expr: &seqExpr{
							pos: position{line: 117, col: 70, offset: 4477},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 117, col: 70, offset: 4477},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&ruleRefExpr{
									pos:  position{line: 117, col: 74, offset: 4481},
									name: "sp",
								},
								&labeledExpr{
									pos:   position{line: 117, col: 77, offset: 4484},
									label: "id2",
									expr: &ruleRefExpr{
										pos:  position{line: 117, col: 81, offset: 4488},
										name: "identifier",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 117, col: 92, offset: 4499},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 117, col: 129, offset: 4536},
						run: (*parser).callonstmtAssignType514,
						expr: &seqExpr{
							pos: position{line: 117, col: 129, offset: 4536},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 117, col: 129, offset: 4536},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&ruleRefExpr{
									pos:  position{line: 117, col: 133, offset: 4540},
									name: "sp",
								},
								&ruleRefExpr{
									pos:  position{line: 117, col: 136, offset: 4543},
									name: "exprRoot",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "stmtAssignType6",
			pos:  position{line: 118, col: 1, offset: 4649},
			expr: &actionExpr{
				pos: position{line: 118, col: 20, offset: 4668},
				run: (*parser).callonstmtAssignType61,
				expr: &seqExpr{
					pos: position{line: 118, col: 20, offset: 4668},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 118, col: 20, offset: 4668},
							name: "exprRoot",
						},
						&litMatcher{
							pos:        position{line: 118, col: 29, offset: 4677},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&ruleRefExpr{
							pos:  position{line: 118, col: 33, offset: 4681},
							name: "sp",
						},
						&ruleRefExpr{
							pos:  position{line: 118, col: 36, offset: 4684},
							name: "exprRoot",
						},
						&litMatcher{
							pos:        position{line: 118, col: 45, offset: 4693},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
						&ruleRefExpr{
							pos:  position{line: 118, col: 49, offset: 4697},
							name: "sp",
						},
						&litMatcher{
							pos:        position{line: 118, col: 52, offset: 4700},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&ruleRefExpr{
							pos:  position{line: 118, col: 56, offset: 4704},
							name: "sp",
						},
						&ruleRefExpr{
							pos:  position{line: 118, col: 59, offset: 4707},
							name: "exprRoot",
						},
					},
				},
			},
		},
		{
			name: "stmtAssignType7",
			pos:  position{line: 119, col: 1, offset: 4746},
			expr: &actionExpr{
				pos: position{line: 119, col: 20, offset: 4765},
				run: (*parser).callonstmtAssignType71,
				expr: &seqExpr{
					pos: position{line: 119, col: 20, offset: 4765},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 119, col: 20, offset: 4765},
							name: "exprRoot",
						},
						&ruleRefExpr{
							pos:  position{line: 119, col: 29, offset: 4774},
							name: "_sliceSuffix",
						},
						&litMatcher{
							pos:        position{line: 119, col: 42, offset: 4787},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&ruleRefExpr{
							pos:  position{line: 119, col: 46, offset: 4791},
							name: "sp",
						},
						&ruleRefExpr{
							pos:  position{line: 119, col: 49, offset: 4794},
							name: "exprRoot",
						},
					},
				},
			},
		},
		{
			name: "stmtAssign",
			pos:  position{line: 121, col: 1, offset: 4835},
			expr: &choiceExpr{
				pos: position{line: 121, col: 15, offset: 4849},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 121, col: 15, offset: 4849},
						exprs: []any{
							&andExpr{
								pos: position{line: 121, col: 15, offset: 4849},
								expr: &ruleRefExpr{
									pos:  position{line: 121, col: 16, offset: 4850},
									name: "stmtAssignType1",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 121, col: 32, offset: 4866},
								name: "stmtAssignType1",
							},
						},
					},
					&seqExpr{
						pos: position{line: 122, col: 15, offset: 4896},
						exprs: []any{
							&andExpr{
								pos: position{line: 122, col: 15, offset: 4896},
								expr: &ruleRefExpr{
									pos:  position{line: 122, col: 16, offset: 4897},
									name: "stmtAssignType2",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 122, col: 32, offset: 4913},
								name: "stmtAssignType2",
							},
						},
					},
					&seqExpr{
						pos: position{line: 123, col: 15, offset: 4943},
						exprs: []any{
							&andExpr{
								pos: position{line: 123, col: 15, offset: 4943},
								expr: &ruleRefExpr{
									pos:  position{line: 123, col: 16, offset: 4944},
									name: "stmtAssignType3",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 123, col: 32, offset: 4960},
								name: "stmtAssignType3",
							},
						},
					},
					&seqExpr{
						pos: position{line: 124, col: 15, offset: 4990},
						exprs: []any{
							&andExpr{
								pos: position{line: 124, col: 15, offset: 4990},
								expr: &ruleRefExpr{
									pos:  position{line: 124, col: 16, offset: 4991},
									name: "stmtAssignType4",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 124, col: 32, offset: 5007},
								name: "stmtAssignType4",
							},
						},
					},
					&seqExpr{
						pos: position{line: 127, col: 15, offset: 5267},
						exprs: []any{
							&andExpr{
								pos: position{line: 127, col: 15, offset: 5267},
								expr: &ruleRefExpr{
									pos:  position{line: 127, col: 16, offset: 5268},
									name: "stmtAssignType5",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 127, col: 32, offset: 5284},
								name: "stmtAssignType5",
							},
						},
					},
					&seqExpr{
						pos: position{line: 128, col: 15, offset: 5314},
						exprs: []any{
							&andExpr{
								pos: position{line: 128, col: 15, offset: 5314},
								expr: &ruleRefExpr{
									pos:  position{line: 128, col: 16, offset: 5315},
									name: "stmtAssignType6",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 128, col: 32, offset: 5331},
								name: "stmtAssignType6",
							},
						},
					},
					&seqExpr{
						pos: position{line: 129, col: 15, offset: 5361},
						exprs: []any{
							&andExpr{
								pos: position{line: 129, col: 15, offset: 5361},
								expr: &ruleRefExpr{
									pos:  position{line: 129, col: 16, offset: 5362},
									name: "stmtAssignType7",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 129, col: 32, offset: 5378},
								name: "stmtAssignType7",
							},
						},
					},
				},
			},
		},
		{
			name: "exprRoot",
			pos:  position{line: 131, col: 1, offset: 5395},
			expr: &seqExpr{
				pos: position{line: 131, col: 13, offset: 5407},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 131, col: 13, offset: 5407},
						name: "exprSlice",
					},
					&ruleRefExpr{
						pos:  position{line: 131, col: 23, offset: 5417},
						name: "sp",
					},
				},
			},
		},
		{
			name: "_step",
			pos:  position{line: 133, col: 1, offset: 5421},
			expr: &choiceExpr{
				pos: position{line: 133, col: 11, offset: 5431},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 133, col: 11, offset: 5431},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 133, col: 11, offset: 5431},
								val:        ":",
								ignoreCase: false,
								want:       "\":\"",
							},
							&ruleRefExpr{
								pos:  position{line: 133, col: 15, offset: 5435},
								name: "sp",
							},
							&choiceExpr{
								pos: position{line: 133, col: 19, offset: 5439},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 133, col: 19, offset: 5439},
										name: "exprRoot",
									},
									&actionExpr{
										pos: position{line: 133, col: 30, offset: 5450},
										run: (*parser).callon_step7,
										expr: &ruleRefExpr{
											pos:  position{line: 133, col: 30, offset: 5450},
											name: "sp",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 133, col: 63, offset: 5483},
						run: (*parser).callon_step9,
						expr: &ruleRefExpr{
							pos:  position{line: 133, col: 63, offset: 5483},
							name: "sp",
						},
					},
				},
			},
		},
		{
			name: "_sliceSuffix",
			pos:  position{line: 134, col: 1, offset: 5514},
			expr: &seqExpr{
				pos: position{line: 134, col: 17, offset: 5530},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 134, col: 17, offset: 5530},
						val:        "[",
						ignoreCase: false,
						want:       "\"[\"",
					},
					&ruleRefExpr{
						pos:  position{line: 134, col: 21, offset: 5534},
						name: "sp",
					},
					&choiceExpr{
						pos: position{line: 134, col: 25, offset: 5538},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 134, col: 25, offset: 5538},
								name: "exprRoot",
							},
							&actionExpr{
								pos: position{line: 134, col: 36, offset: 5549},
								run: (*parser).callon_sliceSuffix6,
								expr: &ruleRefExpr{
									pos:  position{line: 134, col: 36, offset: 5549},
									name: "sp",
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 134, col: 67, offset: 5580},
						val:        ":",
						ignoreCase: false,
						want:       "\":\"",
					},
					&ruleRefExpr{
						pos:  position{line: 134, col: 71, offset: 5584},
						name: "sp",
					},
					&choiceExpr{
						pos: position{line: 134, col: 75, offset: 5588},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 134, col: 75, offset: 5588},
								name: "exprRoot",
							},
							&actionExpr{
								pos: position{line: 134, col: 86, offset: 5599},
								run: (*parser).callon_sliceSuffix12,
								expr: &ruleRefExpr{
									pos:  position{line: 134, col: 86, offset: 5599},
									name: "sp",
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 134, col: 117, offset: 5630},
						name: "_step",
					},
					&litMatcher{
						pos:        position{line: 134, col: 123, offset: 5636},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
					&ruleRefExpr{
						pos:  position{line: 134, col: 127, offset: 5640},
						name: "sp",
					},
				},
			},
		},
		{
			name: "exprSliceType1",
			pos:  position{line: 136, col: 1, offset: 5644},
			expr: &actionExpr{
				pos: position{line: 136, col: 19, offset: 5662},
				run: (*parser).callonexprSliceType11,
				expr: &seqExpr{
					pos: position{line: 136, col: 19, offset: 5662},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 136, col: 19, offset: 5662},
							name: "exprTernary",
						},
						&ruleRefExpr{
							pos:  position{line: 136, col: 31, offset: 5674},
							name: "_sliceSuffix",
						},
						&notExpr{
							pos: position{line: 136, col: 45, offset: 5688},
							expr: &litMatcher{
								pos:        position{line: 136, col: 46, offset: 5689},
								val:        "=",
								ignoreCase: false,
								want:       "\"=\"",
							},
						},
					},
				},
			},
		},
		{
			name: "exprSlice",
			pos:  position{line: 137, col: 1, offset: 5725},
			expr: &choiceExpr{
				pos: position{line: 137, col: 14, offset: 5738},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 137, col: 14, offset: 5738},
						exprs: []any{
							&andExpr{
								pos: position{line: 137, col: 14, offset: 5738},
								expr: &ruleRefExpr{
									pos:  position{line: 137, col: 15, offset: 5739},
									name: "exprSliceType1",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 137, col: 30, offset: 5754},
								name: "exprSliceType1",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 138, col: 14, offset: 5782},
						name: "exprTernary",
					},
				},
			},
		},
		{
			name: "exprValueIfExists",
			pos:  position{line: 141, col: 1, offset: 5815},
			expr: &seqExpr{
				pos: position{line: 141, col: 22, offset: 5836},
				exprs: []any{
					&actionExpr{
						pos: position{line: 141, col: 22, offset: 5836},
						run: (*parser).callonexprValueIfExists2,
						expr: &seqExpr{
							pos: position{line: 141, col: 22, offset: 5836},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 141, col: 22, offset: 5836},
									name: "exprLogicOr",
								},
								&ruleRefExpr{
									pos:  position{line: 141, col: 34, offset: 5848},
									name: "sp",
								},
								&litMatcher{
									pos:        position{line: 141, col: 37, offset: 5851},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
								&ruleRefExpr{
									pos:  position{line: 141, col: 41, offset: 5855},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 141, col: 91, offset: 5905},
						run: (*parser).callonexprValueIfExists8,
						expr: &seqExpr{
							pos: position{line: 141, col: 91, offset: 5905},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 141, col: 91, offset: 5905},
									name: "exprLogicOr",
								},
								&ruleRefExpr{
									pos:  position{line: 141, col: 103, offset: 5917},
									name: "sp",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprTernaryType1",
			pos:  position{line: 142, col: 1, offset: 6052},
			expr: &seqExpr{
				pos: position{line: 142, col: 21, offset: 6072},
				exprs: []any{
					&actionExpr{
						pos: position{line: 142, col: 21, offset: 6072},
						run: (*parser).callonexprTernaryType12,
						expr: &seqExpr{
							pos: position{line: 142, col: 21, offset: 6072},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 142, col: 21, offset: 6072},
									name: "exprLogicOr",
								},
								&ruleRefExpr{
									pos:  position{line: 142, col: 33, offset: 6084},
									name: "sp",
								},
								&litMatcher{
									pos:        position{line: 142, col: 36, offset: 6087},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
								&ruleRefExpr{
									pos:  position{line: 142, col: 40, offset: 6091},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 142, col: 90, offset: 6141},
						run: (*parser).callonexprTernaryType18,
						expr: &seqExpr{
							pos: position{line: 142, col: 90, offset: 6141},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 142, col: 90, offset: 6141},
									name: "exprLogicOr",
								},
								&ruleRefExpr{
									pos:  position{line: 142, col: 102, offset: 6153},
									name: "sp",
								},
								&litMatcher{
									pos:        position{line: 142, col: 105, offset: 6156},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&ruleRefExpr{
									pos:  position{line: 142, col: 109, offset: 6160},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 142, col: 185, offset: 6236},
						run: (*parser).callonexprTernaryType114,
						expr: &seqExpr{
							pos: position{line: 142, col: 185, offset: 6236},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 142, col: 185, offset: 6236},
									name: "exprLogicOr",
								},
								&ruleRefExpr{
									pos:  position{line: 142, col: 197, offset: 6248},
									name: "sp",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprTernaryType2",
			pos:  position{line: 143, col: 1, offset: 6280},
			expr: &seqExpr{
				pos: position{line: 143, col: 21, offset: 6300},
				exprs: []any{
					&actionExpr{
						pos: position{line: 143, col: 21, offset: 6300},
						run: (*parser).callonexprTernaryType22,
						expr: &ruleRefExpr{
							pos:  position{line: 143, col: 21, offset: 6300},
							name: "exprValueIfExists",
						},
					},
					&actionExpr{
						pos: position{line: 143, col: 64, offset: 6343},
						run: (*parser).callonexprTernaryType24,
						expr: &zeroOrMoreExpr{
							pos: position{line: 143, col: 64, offset: 6343},
							expr: &actionExpr{
								pos: position{line: 143, col: 66, offset: 6345},
								run: (*parser).callonexprTernaryType26,
								expr: &seqExpr{
									pos: position{line: 143, col: 66, offset: 6345},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 143, col: 66, offset: 6345},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&ruleRefExpr{
											pos:  position{line: 143, col: 70, offset: 6349},
											name: "sp",
										},
										&ruleRefExpr{
											pos:  position{line: 143, col: 73, offset: 6352},
											name: "exprValueIfExists",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprTernary",
			pos:  position{line: 144, col: 1, offset: 6512},
			expr: &choiceExpr{
				pos: position{line: 144, col: 16, offset: 6527},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 144, col: 16, offset: 6527},
						exprs: []any{
							&andExpr{
								pos: position{line: 144, col: 16, offset: 6527},
								expr: &ruleRefExpr{
									pos:  position{line: 144, col: 17, offset: 6528},
									name: "exprTernaryType1",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 144, col: 34, offset: 6545},
								name: "exprTernaryType1",
							},
						},
					},
					&seqExpr{
						pos: position{line: 145, col: 16, offset: 6577},
						exprs: []any{
							&andExpr{
								pos: position{line: 145, col: 16, offset: 6577},
								expr: &ruleRefExpr{
									pos:  position{line: 145, col: 17, offset: 6578},
									name: "exprTernaryType2",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 145, col: 34, offset: 6595},
								name: "exprTernaryType2",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 146, col: 16, offset: 6627},
						name: "exprLogicOr",
					},
				},
			},
		},
		{
			name: "exprLogicOr",
			pos:  position{line: 163, col: 1, offset: 6868},
			expr: &seqExpr{
				pos: position{line: 163, col: 16, offset: 6883},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 163, col: 16, offset: 6883},
						name: "exprLogicAnd",
					},
					&ruleRefExpr{
						pos:  position{line: 163, col: 29, offset: 6896},
						name: "sp",
					},
					&zeroOrMoreExpr{
						pos: position{line: 163, col: 32, offset: 6899},
						expr: &seqExpr{
							pos: position{line: 163, col: 33, offset: 6900},
							exprs: []any{
								&actionExpr{
									pos: position{line: 163, col: 33, offset: 6900},
									run: (*parser).callonexprLogicOr6,
									expr: &ruleRefExpr{
										pos:  position{line: 163, col: 33, offset: 6900},
										name: "logicOr",
									},
								},
								&actionExpr{
									pos: position{line: 163, col: 88, offset: 6955},
									run: (*parser).callonexprLogicOr8,
									expr: &ruleRefExpr{
										pos:  position{line: 163, col: 88, offset: 6955},
										name: "exprLogicAnd",
									},
								},
								&codeExpr{
									pos: position{line: 163, col: 149, offset: 7016},
									run: (*parser).callonexprLogicOr10,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprLogicAnd",
			pos:  position{line: 164, col: 1, offset: 7104},
			expr: &seqExpr{
				pos: position{line: 164, col: 17, offset: 7120},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 164, col: 17, offset: 7120},
						name: "exprBitwiseOr",
					},
					&ruleRefExpr{
						pos:  position{line: 164, col: 31, offset: 7134},
						name: "sp",
					},
					&zeroOrMoreExpr{
						pos: position{line: 164, col: 34, offset: 7137},
						expr: &actionExpr{
							pos: position{line: 164, col: 35, offset: 7138},
							run: (*parser).callonexprLogicAnd5,
							expr: &seqExpr{
								pos: position{line: 164, col: 35, offset: 7138},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 164, col: 35, offset: 7138},
										name: "logicAnd",
									},
									&ruleRefExpr{
										pos:  position{line: 164, col: 44, offset: 7147},
										name: "exprBitwiseOr",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprBitwiseOr",
			pos:  position{line: 167, col: 1, offset: 7209},
			expr: &choiceExpr{
				pos: position{line: 167, col: 18, offset: 7226},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 167, col: 18, offset: 7226},
						exprs: []any{
							&andCodeExpr{
								pos: position{line: 167, col: 18, offset: 7226},
								run: (*parser).callonexprBitwiseOr3,
							},
							&ruleRefExpr{
								pos:  position{line: 167, col: 59, offset: 7267},
								name: "exprCompare",
							},
						},
					},
					&seqExpr{
						pos: position{line: 168, col: 18, offset: 7333},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 168, col: 18, offset: 7333},
								name: "exprBitwiseAnd",
							},
							&ruleRefExpr{
								pos:  position{line: 168, col: 33, offset: 7348},
								name: "sp",
							},
							&zeroOrMoreExpr{
								pos: position{line: 168, col: 36, offset: 7351},
								expr: &actionExpr{
									pos: position{line: 168, col: 37, offset: 7352},
									run: (*parser).callonexprBitwiseOr9,
									expr: &seqExpr{
										pos: position{line: 168, col: 37, offset: 7352},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 168, col: 37, offset: 7352},
												name: "bitwiseOr",
											},
											&ruleRefExpr{
												pos:  position{line: 168, col: 47, offset: 7362},
												name: "exprBitwiseAnd",
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprBitwiseAnd",
			pos:  position{line: 169, col: 1, offset: 7411},
			expr: &seqExpr{
				pos: position{line: 169, col: 19, offset: 7429},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 169, col: 19, offset: 7429},
						name: "exprCompare",
					},
					&ruleRefExpr{
						pos:  position{line: 169, col: 31, offset: 7441},
						name: "sp",
					},
					&zeroOrMoreExpr{
						pos: position{line: 169, col: 34, offset: 7444},
						expr: &actionExpr{
							pos: position{line: 169, col: 35, offset: 7445},
							run: (*parser).callonexprBitwiseAnd5,
							expr: &seqExpr{
								pos: position{line: 169, col: 35, offset: 7445},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 169, col: 35, offset: 7445},
										name: "bitwiseAnd",
									},
									&ruleRefExpr{
										pos:  position{line: 169, col: 46, offset: 7456},
										name: "exprCompare",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprCompare",
			pos:  position{line: 173, col: 1, offset: 7515},
			expr: &seqExpr{
				pos: position{line: 173, col: 16, offset: 7530},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 173, col: 16, offset: 7530},
						name: "exprAdditive",
					},
					&ruleRefExpr{
						pos:  position{line: 173, col: 29, offset: 7543},
						name: "sp",
					},
					&zeroOrMoreExpr{
						pos: position{line: 173, col: 32, offset: 7546},
						expr: &choiceExpr{
							pos: position{line: 174, col: 18, offset: 7565},
							alternatives: []any{
								&actionExpr{
									pos: position{line: 174, col: 18, offset: 7565},
									run: (*parser).callonexprCompare6,
									expr: &seqExpr{
										pos: position{line: 174, col: 18, offset: 7565},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 174, col: 18, offset: 7565},
												name: "lt",
											},
											&ruleRefExpr{
												pos:  position{line: 174, col: 21, offset: 7568},
												name: "exprAdditive",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 175, col: 18, offset: 7627},
									run: (*parser).callonexprCompare10,
									expr: &seqExpr{
										pos: position{line: 175, col: 18, offset: 7627},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 175, col: 18, offset: 7627},
												name: "le",
											},
											&ruleRefExpr{
												pos:  position{line: 175, col: 21, offset: 7630},
												name: "exprAdditive",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 176, col: 18, offset: 7689},
									run: (*parser).callonexprCompare14,
									expr: &seqExpr{
										pos: position{line: 176, col: 18, offset: 7689},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 176, col: 18, offset: 7689},
												name: "eq",
											},
											&ruleRefExpr{
												pos:  position{line: 176, col: 21, offset: 7692},
												name: "exprAdditive",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 177, col: 18, offset: 7751},
									run: (*parser).callonexprCompare18,
									expr: &seqExpr{
										pos: position{line: 177, col: 18, offset: 7751},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 177, col: 18, offset: 7751},
												name: "ne",
											},
											&ruleRefExpr{
												pos:  position{line: 177, col: 21, offset: 7754},
												name: "exprAdditive",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 178, col: 18, offset: 7813},
									run: (*parser).callonexprCompare22,
									expr: &seqExpr{
										pos: position{line: 178, col: 18, offset: 7813},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 178, col: 18, offset: 7813},
												name: "ge",
											},
											&ruleRefExpr{
												pos:  position{line: 178, col: 21, offset: 7816},
												name: "exprAdditive",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 179, col: 18, offset: 7875},
									run: (*parser).callonexprCompare26,
									expr: &seqExpr{
										pos: position{line: 179, col: 18, offset: 7875},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 179, col: 18, offset: 7875},
												name: "gt",
											},
											&ruleRefExpr{
												pos:  position{line: 179, col: 21, offset: 7878},
												name: "exprAdditive",
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprAdditive",
			pos:  position{line: 183, col: 1, offset: 7947},
			expr: &seqExpr{
				pos: position{line: 183, col: 17, offset: 7963},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 183, col: 17, offset: 7963},
						name: "exprMultiplicative",
					},
					&ruleRefExpr{
						pos:  position{line: 183, col: 36, offset: 7982},
						name: "sp",
					},
					&zeroOrMoreExpr{
						pos: position{line: 183, col: 39, offset: 7985},
						expr: &choiceExpr{
							pos: position{line: 184, col: 19, offset: 8005},
							alternatives: []any{
								&actionExpr{
									pos: position{line: 184, col: 19, offset: 8005},
									run: (*parser).callonexprAdditive6,
									expr: &seqExpr{
										pos: position{line: 184, col: 19, offset: 8005},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 184, col: 19, offset: 8005},
												name: "add",
											},
											&ruleRefExpr{
												pos:  position{line: 184, col: 23, offset: 8009},
												name: "exprMultiplicative",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 185, col: 19, offset: 8072},
									run: (*parser).callonexprAdditive10,
									expr: &seqExpr{
										pos: position{line: 185, col: 19, offset: 8072},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 185, col: 19, offset: 8072},
												name: "minus",
											},
											&ruleRefExpr{
												pos:  position{line: 185, col: 25, offset: 8078},
												name: "exprMultiplicative",
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprMultiplicative",
			pos:  position{line: 189, col: 1, offset: 8159},
			expr: &seqExpr{
				pos: position{line: 189, col: 23, offset: 8181},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 189, col: 23, offset: 8181},
						name: "exprNullCoalescing",
					},
					&ruleRefExpr{
						pos:  position{line: 189, col: 42, offset: 8200},
						name: "sp",
					},
					&zeroOrMoreExpr{
						pos: position{line: 189, col: 45, offset: 8203},
						expr: &choiceExpr{
							pos: position{line: 190, col: 25, offset: 8229},
							alternatives: []any{
								&actionExpr{
									pos: position{line: 190, col: 25, offset: 8229},
									run: (*parser).callonexprMultiplicative6,
									expr: &seqExpr{
										pos: position{line: 190, col: 25, offset: 8229},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 190, col: 25, offset: 8229},
												name: "multiply",
											},
											&ruleRefExpr{
												pos:  position{line: 190, col: 34, offset: 8238},
												name: "exprExp",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 191, col: 25, offset: 8301},
									run: (*parser).callonexprMultiplicative10,
									expr: &seqExpr{
										pos: position{line: 191, col: 25, offset: 8301},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 191, col: 25, offset: 8301},
												name: "divide",
											},
											&ruleRefExpr{
												pos:  position{line: 191, col: 32, offset: 8308},
												name: "exprExp",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 192, col: 25, offset: 8369},
									run: (*parser).callonexprMultiplicative14,
									expr: &seqExpr{
										pos: position{line: 192, col: 25, offset: 8369},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 192, col: 25, offset: 8369},
												name: "modulus",
											},
											&ruleRefExpr{
												pos:  position{line: 192, col: 33, offset: 8377},
												name: "exprExp",
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprNullCoalescing",
			pos:  position{line: 196, col: 1, offset: 8455},
			expr: &seqExpr{
				pos: position{line: 196, col: 23, offset: 8477},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 196, col: 23, offset: 8477},
						name: "exprExp",
					},
					&ruleRefExpr{
						pos:  position{line: 196, col: 31, offset: 8485},
						name: "sp",
					},
					&zeroOrMoreExpr{
						pos: position{line: 196, col: 34, offset: 8488},
						expr: &actionExpr{
							pos: position{line: 197, col: 25, offset: 8514},
							run: (*parser).callonexprNullCoalescing5,
							expr: &seqExpr{
								pos: position{line: 197, col: 25, offset: 8514},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 197, col: 25, offset: 8514},
										name: "nullCoalescing",
									},
									&ruleRefExpr{
										pos:  position{line: 197, col: 40, offset: 8529},
										name: "exprExp",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprExp",
			pos:  position{line: 201, col: 1, offset: 8608},
			expr: &seqExpr{
				pos: position{line: 201, col: 12, offset: 8619},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 201, col: 12, offset: 8619},
						name: "exprUnaryNeg",
					},
					&ruleRefExpr{
						pos:  position{line: 201, col: 25, offset: 8632},
						name: "sp",
					},
					&zeroOrMoreExpr{
						pos: position{line: 201, col: 28, offset: 8635},
						expr: &actionExpr{
							pos: position{line: 202, col: 14, offset: 8650},
							run: (*parser).callonexprExp5,
							expr: &seqExpr{
								pos: position{line: 202, col: 14, offset: 8650},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 202, col: 14, offset: 8650},
										name: "exponentiation",
									},
									&ruleRefExpr{
										pos:  position{line: 202, col: 29, offset: 8665},
										name: "exprUnaryNeg",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "exprUnaryNeg",
			pos:  position{line: 206, col: 1, offset: 8745},
			expr: &choiceExpr{
				pos: position{line: 206, col: 17, offset: 8761},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 206, col: 17, offset: 8761},
						run: (*parser).callonexprUnaryNeg2,
						expr: &seqExpr{
							pos: position{line: 206, col: 17, offset: 8761},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 206, col: 17, offset: 8761},
									name: "minus",
								},
								&ruleRefExpr{
									pos:  position{line: 206, col: 23, offset: 8767},
									name: "exprRoot",
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 207, col: 17, offset: 8823},
						name: "exprUnaryPos",
					},
				},
			},
		},
		{
			name: "exprUnaryPos",
			pos:  position{line: 209, col: 1, offset: 8837},
			expr: &choiceExpr{
				pos: position{line: 209, col: 17, offset: 8853},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 209, col: 17, offset: 8853},
						run: (*parser).callonexprUnaryPos2,
						expr: &seqExpr{
							pos: position{line: 209, col: 17, offset: 8853},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 209, col: 17, offset: 8853},
									name: "add",
								},
								&ruleRefExpr{
									pos:  position{line: 209, col: 21, offset: 8857},
									name: "exprRoot",
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 210, col: 17, offset: 8913},
						name: "exprDice",
					},
				},
			},
		},
		{
			name: "nos",
			pos:  position{line: 213, col: 1, offset: 8939},
			expr: &choiceExpr{
				pos: position{line: 213, col: 9, offset: 8947},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 213, col: 9, offset: 8947},
						name: "number",
					},
					&ruleRefExpr{
						pos:  position{line: 213, col: 18, offset: 8956},
						name: "sub",
					},
				},
			},
		},
		{
			name: "detailStart",
			pos:  position{line: 214, col: 1, offset: 8961},
			expr: &codeExpr{
				pos: position{line: 214, col: 16, offset: 8976},
				run: (*parser).callondetailStart1,
			},
		},
		{
			name: "detailEnd",
			pos:  position{line: 215, col: 1, offset: 9043},
			expr: &codeExpr{
				pos: position{line: 215, col: 14, offset: 9056},
				run: (*parser).callondetailEnd1,
			},
		},
		{
			name: "_diceMod",
			pos:  position{line: 217, col: 1, offset: 9126},
			expr: &choiceExpr{
				pos: position{line: 217, col: 13, offset: 9138},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 217, col: 13, offset: 9138},
						run: (*parser).callon_diceMod2,
						expr: &seqExpr{
							pos: position{line: 217, col: 13, offset: 9138},
							exprs: []any{
								&choiceExpr{
									pos: position{line: 217, col: 14, offset: 9139},
									alternatives: []any{
										&litMatcher{
											pos:        position{line: 217, col: 14, offset: 9139},
											val:        "kl",
											ignoreCase: false,
											want:       "\"kl\"",
										},
										&charClassMatcher{
											pos:        position{line: 217, col: 21, offset: 9146},
											val:        "[qQ]",
											chars:      []rune{'q', 'Q'},
											ignoreCase: false,
											inverted:   false,
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 217, col: 27, offset: 9152},
									name: "nos",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 218, col: 13, offset: 9232},
						run: (*parser).callon_diceMod8,
						expr: &choiceExpr{
							pos: position{line: 218, col: 14, offset: 9233},
							alternatives: []any{
								&litMatcher{
									pos:        position{line: 218, col: 14, offset: 9233},
									val:        "kl",
									ignoreCase: false,
									want:       "\"kl\"",
								},
								&charClassMatcher{
									pos:        position{line: 218, col: 21, offset: 9240},
									val:        "[qQ]",
									chars:      []rune{'q', 'Q'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 219, col: 13, offset: 9326},
						run: (*parser).callon_diceMod12,
						expr: &seqExpr{
							pos: position{line: 219, col: 13, offset: 9326},
							exprs: []any{
								&choiceExpr{
									pos: position{line: 219, col: 14, offset: 9327},
									alternatives: []any{
										&litMatcher{
											pos:        position{line: 219, col: 14, offset: 9327},
											val:        "kh",
											ignoreCase: false,
											want:       "\"kh\"",
										},
										&charClassMatcher{
											pos:        position{line: 219, col: 21, offset: 9334},
											val:        "[kK]",
											chars:      []rune{'k', 'K'},
											ignoreCase: false,
											inverted:   false,
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 219, col: 27, offset: 9340},
									name: "nos",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 220, col: 13, offset: 9430},
						run: (*parser).callon_diceMod18,
						expr: &choiceExpr{
							pos: position{line: 220, col: 14, offset: 9431},
							alternatives: []any{
								&litMatcher{
									pos:        position{line: 220, col: 14, offset: 9431},
									val:        "kh",
									ignoreCase: false,
									want:       "\"kh\"",
								},
								&charClassMatcher{
									pos:        position{line: 220, col: 21, offset: 9438},
									val:        "[kK]",
									chars:      []rune{'k', 'K'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 221, col: 13, offset: 9525},
						run: (*parser).callon_diceMod22,
						expr: &seqExpr{
							pos: position{line: 221, col: 13, offset: 9525},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 221, col: 14, offset: 9526},
									val:        "dh",
									ignoreCase: false,
									want:       "\"dh\"",
								},
								&ruleRefExpr{
									pos:  position{line: 221, col: 20, offset: 9532},
									name: "nos",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 222, col: 13, offset: 9657},
						run: (*parser).callon_diceMod26,
						expr: &litMatcher{
							pos:        position{line: 222, col: 14, offset: 9658},
							val:        "dh",
							ignoreCase: false,
							want:       "\"dh\"",
						},
					},
					&actionExpr{
						pos: position{line: 223, col: 13, offset: 9791},
						run: (*parser).callon_diceMod28,
						expr: &seqExpr{
							pos: position{line: 223, col: 13, offset: 9791},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 223, col: 14, offset: 9792},
									val:        "dl",
									ignoreCase: false,
									want:       "\"dl\"",
								},
								&ruleRefExpr{
									pos:  position{line: 223, col: 20, offset: 9798},
									name: "nos",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 224, col: 13, offset: 9932},
						run: (*parser).callon_diceMod32,
						expr: &litMatcher{
							pos:        position{line: 224, col: 14, offset: 9933},
							val:        "dl",
							ignoreCase: false,
							want:       "\"dl\"",
						},
					},
				},
			},
		},
		{
			name: "_diceModType2",
			pos:  position{line: 226, col: 1, offset: 10008},
			expr: &choiceExpr{
				pos: position{line: 226, col: 18, offset: 10025},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 226, col: 18, offset: 10025},
						run: (*parser).callon_diceModType22,
						expr: &seqExpr{
							pos: position{line: 226, col: 18, offset: 10025},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 226, col: 18, offset: 10025},
									val:        "min",
									ignoreCase: false,
									want:       "\"min\"",
								},
								&ruleRefExpr{
									pos:  position{line: 226, col: 24, offset: 10031},
									name: "nos",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 227, col: 18, offset: 10085},
						run: (*parser).callon_diceModType26,
						expr: &seqExpr{
							pos: position{line: 227, col: 18, offset: 10085},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 227, col: 18, offset: 10085},
									val:        "max",
									ignoreCase: false,
									want:       "\"max\"",
								},
								&ruleRefExpr{
									pos:  position{line: 227, col: 24, offset: 10091},
									name: "nos",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_dicePearMod",
			pos:  position{line: 229, col: 1, offset: 10129},
			expr: &choiceExpr{
				pos: position{line: 229, col: 17, offset: 10145},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 229, col: 17, offset: 10145},
						run: (*parser).callon_dicePearMod2,
						expr: &litMatcher{
							pos:        position{line: 229, col: 17, offset: 10145},
							val:        "优势",
							ignoreCase: false,
							want:       "\"优势\"",
						},
					},
					&actionExpr{
						pos: position{line: 230, col: 17, offset: 10298},
						run: (*parser).callon_dicePearMod4,
						expr: &litMatcher{
							pos:        position{line: 230, col: 17, offset: 10298},
							val:        "劣势",
							ignoreCase: false,
							want:       "\"劣势\"",
						},
					},
				},
			},
		},
		{
			name: "_diceType1",
			pos:  position{line: 233, col: 1, offset: 10463},
			expr: &seqExpr{
				pos: position{line: 233, col: 15, offset: 10477},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 233, col: 15, offset: 10477},
						name: "nos",
					},
					&charClassMatcher{
						pos:        position{line: 233, col: 19, offset: 10481},
						val:        "[dD]",
						chars:      []rune{'d', 'D'},
						ignoreCase: false,
						inverted:   false,
					},
					&ruleRefExpr{
						pos:  position{line: 233, col: 24, offset: 10486},
						name: "nos",
					},
				},
			},
		},
		{
			name: "_diceType2",
			pos:  position{line: 235, col: 1, offset: 10497},
			expr: &seqExpr{
				pos: position{line: 235, col: 15, offset: 10511},
				exprs: []any{
					&charClassMatcher{
						pos:        position{line: 235, col: 15, offset: 10511},
						val:        "[dD]",
						chars:      []rune{'d', 'D'},
						ignoreCase: false,
						inverted:   false,
					},
					&ruleRefExpr{
						pos:  position{line: 235, col: 20, offset: 10516},
						name: "nos",
					},
				},
			},
		},
		{
			name: "_diceType3",
			pos:  position{line: 237, col: 1, offset: 10526},
			expr: &seqExpr{
				pos: position{line: 237, col: 15, offset: 10540},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 237, col: 15, offset: 10540},
						name: "nos",
					},
					&charClassMatcher{
						pos:        position{line: 237, col: 19, offset: 10544},
						val:        "[dD]",
						chars:      []rune{'d', 'D'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "_diceType4",
			pos:  position{line: 239, col: 1, offset: 10554},
			expr: &charClassMatcher{
				pos:        position{line: 239, col: 15, offset: 10568},
				val:        "[dD]",
				chars:      []rune{'d', 'D'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "_diceExpr1",
			pos:  position{line: 242, col: 1, offset: 10634},
			expr: &seqExpr{
				pos: position{line: 242, col: 15, offset: 10648},
				exprs: []any{
					&actionExpr{
						pos: position{line: 242, col: 15, offset: 10648},
						run: (*parser).callon_diceExpr12,
						expr: &charClassMatcher{
							pos:        position{line: 242, col: 15, offset: 10648},
							val:        "[dD]",
							chars:      []rune{'d', 'D'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&seqExpr{
						pos: position{line: 242, col: 96, offset: 10729},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 242, col: 96, offset: 10729},
								name: "nos",
							},
							&zeroOrOneExpr{
								pos: position{line: 242, col: 100, offset: 10733},
								expr: &ruleRefExpr{
									pos:  position{line: 242, col: 100, offset: 10733},
									name: "_diceMod",
								},
							},
							&zeroOrOneExpr{
								pos: position{line: 242, col: 110, offset: 10743},
								expr: &ruleRefExpr{
									pos:  position{line: 242, col: 110, offset: 10743},
									name: "_diceModType2",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_diceExpr2",
			pos:  position{line: 243, col: 1, offset: 10758},
			expr: &seqExpr{
				pos: position{line: 243, col: 15, offset: 10772},
				exprs: []any{
					&actionExpr{
						pos: position{line: 243, col: 15, offset: 10772},
						run: (*parser).callon_diceExpr22,
						expr: &charClassMatcher{
							pos:        position{line: 243, col: 15, offset: 10772},
							val:        "[dD]",
							chars:      []rune{'d', 'D'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&seqExpr{
						pos: position{line: 243, col: 52, offset: 10809},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 243, col: 52, offset: 10809},
								name: "nos",
							},
							&zeroOrOneExpr{
								pos: position{line: 243, col: 56, offset: 10813},
								expr: &choiceExpr{
									pos: position{line: 243, col: 57, offset: 10814},
									alternatives: []any{
										&ruleRefExpr{
											pos:  position{line: 243, col: 57, offset: 10814},
											name: "_dicePearMod",
										},
										&ruleRefExpr{
											pos:  position{line: 243, col: 72, offset: 10829},
											name: "_diceMod",
										},
									},
								},
							},
							&zeroOrOneExpr{
								pos: position{line: 243, col: 83, offset: 10840},
								expr: &ruleRefExpr{
									pos:  position{line: 243, col: 83, offset: 10840},
									name: "_diceModType2",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_diceExpr3",
			pos:  position{line: 244, col: 1, offset: 10855},
			expr: &seqExpr{
				pos: position{line: 244, col: 15, offset: 10869},
				exprs: []any{
					&actionExpr{
						pos: position{line: 244, col: 15, offset: 10869},
						run: (*parser).callon_diceExpr32,
						expr: &charClassMatcher{
							pos:        position{line: 244, col: 15, offset: 10869},
							val:        "[dD]",
							chars:      []rune{'d', 'D'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&seqExpr{
						pos: position{line: 244, col: 84, offset: 10938},
						exprs: []any{
							&zeroOrOneExpr{
								pos: position{line: 244, col: 84, offset: 10938},
								expr: &choiceExpr{
									pos: position{line: 244, col: 85, offset: 10939},
									alternatives: []any{
										&ruleRefExpr{
											pos:  position{line: 244, col: 85, offset: 10939},
											name: "_dicePearMod",
										},
										&ruleRefExpr{
											pos:  position{line: 244, col: 100, offset: 10954},
											name: "_diceMod",
										},
									},
								},
							},
							&zeroOrOneExpr{
								pos: position{line: 244, col: 111, offset: 10965},
								expr: &ruleRefExpr{
									pos:  position{line: 244, col: 111, offset: 10965},
									name: "_diceModType2",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_diceExprX",
			pos:  position{line: 247, col: 1, offset: 11004},
			expr: &actionExpr{
				pos: position{line: 247, col: 15, offset: 11018},
				run: (*parser).callon_diceExprX1,
				expr: &seqExpr{
					pos: position{line: 247, col: 15, offset: 11018},
					exprs: []any{
						&andExpr{
							pos: position{line: 247, col: 15, offset: 11018},
							expr: &ruleRefExpr{
								pos:  position{line: 247, col: 16, offset: 11019},
								name: "_diceType2",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 247, col: 27, offset: 11030},
							name: "detailStart",
						},
						&ruleRefExpr{
							pos:  position{line: 247, col: 39, offset: 11042},
							name: "_diceExpr1",
						},
						&ruleRefExpr{
							pos:  position{line: 247, col: 50, offset: 11053},
							name: "detailEnd",
						},
					},
				},
			},
		},
		{
			name: "_wodTypeMain",
			pos:  position{line: 251, col: 1, offset: 11235},
			expr: &seqExpr{
				pos: position{line: 251, col: 17, offset: 11251},
				exprs: []any{
					&charClassMatcher{
						pos:        position{line: 251, col: 17, offset: 11251},
						val:        "[aA]",
						chars:      []rune{'a', 'A'},
						ignoreCase: false,
						inverted:   false,
					},
					&ruleRefExpr{
						pos:  position{line: 251, col: 22, offset: 11256},
						name: "nos",
					},
					&zeroOrMoreExpr{
						pos: position{line: 251, col: 26, offset: 11260},
						expr: &choiceExpr{
							pos: position{line: 251, col: 27, offset: 11261},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 251, col: 28, offset: 11262},
									exprs: []any{
										&charClassMatcher{
											pos:        position{line: 251, col: 28, offset: 11262},
											val:        "[mM]",
											chars:      []rune{'m', 'M'},
											ignoreCase: false,
											inverted:   false,
										},
										&ruleRefExpr{
											pos:  position{line: 251, col: 33, offset: 11267},
											name: "nos",
										},
									},
								},
								&seqExpr{
									pos: position{line: 251, col: 41, offset: 11275},
									exprs: []any{
										&charClassMatcher{
											pos:        position{line: 251, col: 41, offset: 11275},
											val:        "[kK]",
											chars:      []rune{'k', 'K'},
											ignoreCase: false,
											inverted:   false,
										},
										&ruleRefExpr{
											pos:  position{line: 251, col: 46, offset: 11280},
											name: "nos",
										},
									},
								},
								&seqExpr{
									pos: position{line: 251, col: 54, offset: 11288},
									exprs: []any{
										&charClassMatcher{
											pos:        position{line: 251, col: 54, offset: 11288},
											val:        "[qQ]",
											chars:      []rune{'q', 'Q'},
											ignoreCase: false,
											inverted:   false,
										},
										&ruleRefExpr{
											pos:  position{line: 251, col: 59, offset: 11293},
											name: "nos",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_wodDiceType",
			pos:  position{line: 252, col: 1, offset: 11300},
			expr: &choiceExpr{
				pos: position{line: 252, col: 17, offset: 11316},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 252, col: 17, offset: 11316},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 252, col: 17, offset: 11316},
								name: "nos",
							},
							&ruleRefExpr{
								pos:  position{line: 252, col: 21, offset: 11320},
								name: "_wodTypeMain",
							},
						},
					},
					&seqExpr{
						pos: position{line: 252, col: 36, offset: 11335},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 252, col: 36, offset: 11335},
								name: "_wodTypeMain",
							},
							&notExpr{
								pos: position{line: 252, col: 49, offset: 11348},
								expr: &ruleRefExpr{
									pos:  position{line: 252, col: 50, offset: 11349},
									name: "xidContinue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_wodMain",
			pos:  position{line: 253, col: 1, offset: 11361},
			expr: &seqExpr{
				pos: position{line: 253, col: 13, offset: 11373},
				exprs: []any{
					&charClassMatcher{
						pos:        position{line: 253, col: 13, offset: 11373},
						val:        "[aA]",
						chars:      []rune{'a', 'A'},
						ignoreCase: false,
						inverted:   false,
					},
					&ruleRefExpr{
						pos:  position{line: 253, col: 18, offset: 11378},
						name: "nos",
					},
					&zeroOrMoreExpr{
						pos: position{line: 253, col: 22, offset: 11382},
						expr: &choiceExpr{
							pos: position{line: 253, col: 23, offset: 11383},
							alternatives: []any{
								&actionExpr{
									pos: position{line: 253, col: 24, offset: 11384},
									run: (*parser).callon_wodMain6,
									expr: &seqExpr{
										pos: position{line: 253, col: 24, offset: 11384},
										exprs: []any{
											&charClassMatcher{
												pos:        position{line: 253, col: 24, offset: 11384},
												val:        "[mM]",
												chars:      []rune{'m', 'M'},
												ignoreCase: false,
												inverted:   false,
											},
											&ruleRefExpr{
												pos:  position{line: 253, col: 29, offset: 11389},
												name: "nos",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 253, col: 72, offset: 11432},
									run: (*parser).callon_wodMain10,
									expr: &seqExpr{
										pos: position{line: 253, col: 72, offset: 11432},
										exprs: []any{
											&charClassMatcher{
												pos:        position{line: 253, col: 72, offset: 11432},
												val:        "[kK]",
												chars:      []rune{'k', 'K'},
												ignoreCase: false,
												inverted:   false,
											},
											&ruleRefExpr{
												pos:  position{line: 253, col: 77, offset: 11437},
												name: "nos",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 253, col: 123, offset: 11483},
									run: (*parser).callon_wodMain14,
									expr: &seqExpr{
										pos: position{line: 253, col: 123, offset: 11483},
										exprs: []any{
											&charClassMatcher{
												pos:        position{line: 253, col: 123, offset: 11483},
												val:        "[qQ]",
												chars:      []rune{'q', 'Q'},
												ignoreCase: false,
												inverted:   false,
											},
											&ruleRefExpr{
												pos:  position{line: 253, col: 128, offset: 11488},
												name: "nos",
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_cocDiceType",
			pos:  position{line: 256, col: 1, offset: 11574},
			expr: &seqExpr{
				pos: position{line: 256, col: 17, offset: 11590},
				exprs: []any{
					&charClassMatcher{
						pos:        position{line: 256, col: 17, offset: 11590},
						val:        "[pPbB]",
						chars:      []rune{'p', 'P', 'b', 'B'},
						ignoreCase: false,
						inverted:   false,
					},
					&choiceExpr{
						pos: position{line: 256, col: 25, offset: 11598},
						alternatives: []any{
							&seqExpr{
								pos: position{line: 256, col: 25, offset: 11598},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 256, col: 25, offset: 11598},
										name: "nos",
									},
									&notExpr{
										pos: position{line: 256, col: 29, offset: 11602},
										expr: &ruleRefExpr{
											pos:  position{line: 256, col: 30, offset: 11603},
											name: "xidContinue",
										},
									},
								},
							},
							&notExpr{
								pos: position{line: 256, col: 44, offset: 11617},
								expr: &ruleRefExpr{
									pos:  position{line: 256, col: 45, offset: 11618},
									name: "xidContinue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_diceCocBonus",
			pos:  position{line: 257, col: 1, offset: 11631},
			expr: &actionExpr{
				pos: position{line: 257, col: 18, offset: 11648},
				run: (*parser).callon_diceCocBonus1,
				expr: &seqExpr{
					pos: position{line: 257, col: 18, offset: 11648},
					exprs: []any{
						&charClassMatcher{
							pos:        position{line: 257, col: 18, offset: 11648},
							val:        "[bB]",
							chars:      []rune{'b', 'B'},
							ignoreCase: false,
							inverted:   false,
						},
						&choiceExpr{
							pos: position{line: 257, col: 24, offset: 11654},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 257, col: 24, offset: 11654},
									exprs: []any{
										&ruleRefExpr{
											pos:  position{line: 257, col: 24, offset: 11654},
											name: "nos",
										},
										&notExpr{
											pos: position{line: 257, col: 28, offset: 11658},
											expr: &ruleRefExpr{
												pos:  position{line: 257, col: 29, offset: 11659},
												name: "xidContinue",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 257, col: 43, offset: 11673},
									run: (*parser).callon_diceCocBonus9,
									expr: &notExpr{
										pos: position{line: 257, col: 43, offset: 11673},
										expr: &ruleRefExpr{
											pos:  position{line: 257, col: 44, offset: 11674},
											name: "xidContinue",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 257, col: 85, offset: 11715},
							name: "detailEnd",
						},
					},
				},
			},
		},
		{
			name: "_diceCocPenalty",
			pos:  position{line: 258, col: 1, offset: 11760},
			expr: &actionExpr{
				pos: position{line: 258, col: 20, offset: 11779},
				run: (*parser).callon_diceCocPenalty1,
				expr: &seqExpr{
					pos: position{line: 258, col: 20, offset: 11779},
					exprs: []any{
						&charClassMatcher{
							pos:        position{line: 258, col: 20, offset: 11779},
							val:        "[pP]",
							chars:      []rune{'p', 'P'},
							ignoreCase: false,
							inverted:   false,
						},
						&choiceExpr{
							pos: position{line: 258, col: 26, offset: 11785},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 258, col: 26, offset: 11785},
									exprs: []any{
										&ruleRefExpr{
											pos:  position{line: 258, col: 26, offset: 11785},
											name: "nos",
										},
										&notExpr{
											pos: position{line: 258, col: 30, offset: 11789},
											expr: &ruleRefExpr{
												pos:  position{line: 258, col: 31, offset: 11790},
												name: "xidContinue",
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 258, col: 45, offset: 11804},
									run: (*parser).callon_diceCocPenalty9,
									expr: &notExpr{
										pos: position{line: 258, col: 45, offset: 11804},
										expr: &ruleRefExpr{
											pos:  position{line: 258, col: 46, offset: 11805},
											name: "xidContinue",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 258, col: 87, offset: 11846},
							name: "detailEnd",
						},
					},
				},
			},
		},
		{
			name: "_dcDiceType",
			pos:  position{line: 261, col: 1, offset: 11913},
			expr: &seqExpr{
				pos: position{line: 261, col: 16, offset: 11928},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 261, col: 16, offset: 11928},
						name: "nos",
					},
					&charClassMatcher{
						pos:        position{line: 261, col: 20, offset: 11932},
						val:        "[cC]",
						chars:      []rune{'c', 'C'},
						ignoreCase: false,
						inverted:   false,
					},
					&ruleRefExpr{
						pos:  position{line: 261, col: 25, offset: 11937},
						name: "nos",
					},
					&zeroOrMoreExpr{
						pos: position{line: 261, col: 29, offset: 11941},
						expr: &seqExpr{
							pos: position{line: 261, col: 30, offset: 11942},
							exprs: []any{
								&charClassMatcher{
									pos:        position{line: 261, col: 30, offset: 11942},
									val:        "[mM]",
									chars:      []rune{'m', 'M'},
									ignoreCase: false,
									inverted:   false,
								},
								&ruleRefExpr{
									pos:  position{line: 261, col: 35, offset: 11947},
									name: "nos",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_fateDiceType",
			pos:  position{line: 264, col: 1, offset: 11968},
			expr: &seqExpr{
				pos: position{line: 264, col: 18, offset: 11985},
				exprs: []any{
					&charClassMatcher{
						pos:        position{line: 264, col: 18, offset: 11985},
						val:        "[fF]",
						chars:      []rune{'f', 'F'},
						ignoreCase: false,
						inverted:   false,
					},
					&notExpr{
						pos: position{line: 264, col: 23, offset: 11990},
						expr: &ruleRefExpr{
							pos:  position{line: 264, col: 24, offset: 11991},
							name: "xidContinue",
						},
					},
				},
			},
		},
		{
			name: "exprDice",
			pos:  position{line: 266, col: 1, offset: 12004},
			expr: &choiceExpr{
				pos: position{line: 266, col: 13, offset: 12016},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 266, col: 13, offset: 12016},
						exprs: []any{
							&actionExpr{
								pos: position{line: 266, col: 13, offset: 12016},
								run: (*parser).callonexprDice3,
								expr: &seqExpr{
									pos: position{line: 266, col: 13, offset: 12016},
									exprs: []any{
										&andExpr{
											pos: position{line: 266, col: 13, offset: 12016},
											expr: &ruleRefExpr{
												pos:  position{line: 266, col: 14, offset: 12017},
												name: "_diceType1",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 266, col: 25, offset: 12028},
											name: "detailStart",
										},
										&ruleRefExpr{
											pos:  position{line: 266, col: 37, offset: 12040},
											name: "nos",
										},
										&ruleRefExpr{
											pos:  position{line: 266, col: 41, offset: 12044},
											name: "_diceExpr1",
										},
										&ruleRefExpr{
											pos:  position{line: 266, col: 52, offset: 12055},
											name: "detailEnd",
										},
									},
								},
							},
							&zeroOrMoreExpr{
								pos: position{line: 266, col: 90, offset: 12093},
								expr: &ruleRefExpr{
									pos:  position{line: 266, col: 90, offset: 12093},
									name: "_diceExprX",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 267, col: 13, offset: 12117},
						exprs: []any{
							&actionExpr{
								pos: position{line: 267, col: 13, offset: 12117},
								run: (*parser).callonexprDice14,
								expr: &seqExpr{
									pos: position{line: 267, col: 13, offset: 12117},
									exprs: []any{
										&andExpr{
											pos: position{line: 267, col: 13, offset: 12117},
											expr: &ruleRefExpr{
												pos:  position{line: 267, col: 14, offset: 12118},
												name: "_diceType2",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 267, col: 25, offset: 12129},
											name: "detailStart",
										},
										&ruleRefExpr{
											pos:  position{line: 267, col: 37, offset: 12141},
											name: "_diceExpr2",
										},
										&ruleRefExpr{
											pos:  position{line: 267, col: 48, offset: 12152},
											name: "detailEnd",
										},
									},
								},
							},
							&zeroOrMoreExpr{
								pos: position{line: 267, col: 85, offset: 12189},
								expr: &ruleRefExpr{
									pos:  position{line: 267, col: 85, offset: 12189},
									name: "_diceExprX",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 268, col: 13, offset: 12213},
						exprs: []any{
							&actionExpr{
								pos: position{line: 268, col: 13, offset: 12213},
								run: (*parser).callonexprDice24,
								expr: &seqExpr{
									pos: position{line: 268, col: 13, offset: 12213},
									exprs: []any{
										&andCodeExpr{
											pos: position{line: 268, col: 13, offset: 12213},
											run: (*parser).callonexprDice26,
										},
										&andExpr{
											pos: position{line: 268, col: 51, offset: 12251},
											expr: &ruleRefExpr{
												pos:  position{line: 268, col: 52, offset: 12252},
												name: "_diceType3",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 268, col: 63, offset: 12263},
											name: "detailStart",
										},
										&ruleRefExpr{
											pos:  position{line: 268, col: 75, offset: 12275},
											name: "nos",
										},
										&ruleRefExpr{
											pos:  position{line: 268, col: 79, offset: 12279},
											name: "_diceExpr3",
										},
										&ruleRefExpr{
											pos:  position{line: 268, col: 90, offset: 12290},
											name: "detailEnd",
										},
									},
								},
							},
							&zeroOrMoreExpr{
								pos: position{line: 268, col: 162, offset: 12362},
								expr: &ruleRefExpr{
									pos:  position{line: 268, col: 162, offset: 12362},
									name: "_diceExprX",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 269, col: 13, offset: 12386},
						exprs: []any{
							&actionExpr{
								pos: position{line: 269, col: 13, offset: 12386},
								run: (*parser).callonexprDice36,
								expr: &seqExpr{
									pos: position{line: 269, col: 13, offset: 12386},
									exprs: []any{
										&andCodeExpr{
											pos: position{line: 269, col: 13, offset: 12386},
											run: (*parser).callonexprDice38,
										},
										&andExpr{
											pos: position{line: 269, col: 51, offset: 12424},
											expr: &ruleRefExpr{
												pos:  position{line: 269, col: 52, offset: 12425},
												name: "_diceType4",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 269, col: 63, offset: 12436},
											name: "detailStart",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 269, col: 105, offset: 12478},
								run: (*parser).callonexprDice42,
								expr: &seqExpr{
									pos: position{line: 269, col: 105, offset: 12478},
									exprs: []any{
										&ruleRefExpr{
											pos:  position{line: 269, col: 105, offset: 12478},
											name: "_diceExpr3",
										},
										&ruleRefExpr{
											pos:  position{line: 269, col: 116, offset: 12489},
											name: "detailEnd",
										},
									},
								},
							},
							&zeroOrMoreExpr{
								pos: position{line: 269, col: 188, offset: 12561},
								expr: &ruleRefExpr{
									pos:  position{line: 269, col: 188, offset: 12561},
									name: "_diceExprX",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 270, col: 13, offset: 12585},
						exprs: []any{
							&andCodeExpr{
								pos: position{line: 270, col: 13, offset: 12585},
								run: (*parser).callonexprDice49,
							},
							&andExpr{
								pos: position{line: 270, col: 51, offset: 12623},
								expr: &ruleRefExpr{
									pos:  position{line: 270, col: 52, offset: 12624},
									name: "_cocDiceType",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 270, col: 65, offset: 12637},
								name: "detailStart",
							},
							&choiceExpr{
								pos: position{line: 270, col: 78, offset: 12650},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 270, col: 78, offset: 12650},
										name: "_diceCocBonus",
									},
									&ruleRefExpr{
										pos:  position{line: 270, col: 94, offset: 12666},
										name: "_diceCocPenalty",
									},
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 271, col: 13, offset: 12695},
						exprs: []any{
							&actionExpr{
								pos: position{line: 271, col: 13, offset: 12695},
								run: (*parser).callonexprDice57,
								expr: &seqExpr{
									pos: position{line: 271, col: 13, offset: 12695},
									exprs: []any{
										&andCodeExpr{
											pos: position{line: 271, col: 13, offset: 12695},
											run: (*parser).callonexprDice59,
										},
										&andExpr{
											pos: position{line: 271, col: 51, offset: 12733},
											expr: &ruleRefExpr{
												pos:  position{line: 271, col: 52, offset: 12734},
												name: "_wodDiceType",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 271, col: 65, offset: 12747},
											name: "detailStart",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 271, col: 110, offset: 12792},
								run: (*parser).callonexprDice63,
								expr: &seqExpr{
									pos: position{line: 271, col: 110, offset: 12792},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 271, col: 111, offset: 12793},
											alternatives: []any{
												&seqExpr{
													pos: position{line: 271, col: 111, offset: 12793},
													exprs: []any{
														&actionExpr{
															pos: position{line: 271, col: 111, offset: 12793},
															run: (*parser).callonexprDice67,
															expr: &ruleRefExpr{
																pos:  position{line: 271, col: 111, offset: 12793},
																name: "nos",
															},
														},
														&ruleRefExpr{
															pos:  position{line: 271, col: 148, offset: 12830},
															name: "_wodMain",
														},
													},
												},
												&seqExpr{
													pos: position{line: 271, col: 159, offset: 12841},
													exprs: []any{
														&ruleRefExpr{
															pos:  position{line: 271, col: 159, offset: 12841},
															name: "_wodMain",
														},
														&notExpr{
															pos: position{line: 271, col: 168, offset: 12850},
															expr: &ruleRefExpr{
																pos:  position{line: 271, col: 169, offset: 12851},
																name: "xidContinue",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 271, col: 182, offset: 12864},
											name: "detailEnd",
										},
									},
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 272, col: 13, offset: 12916},
						exprs: []any{
							&actionExpr{
								pos: position{line: 272, col: 13, offset: 12916},
								run: (*parser).callonexprDice76,
								expr: &seqExpr{
									pos: position{line: 272, col: 13, offset: 12916},
									exprs: []any{
										&andCodeExpr{
											pos: position{line: 272, col: 13, offset: 12916},
											run: (*parser).callonexprDice78,
										},
										&andExpr{
											pos: position{line: 272, col: 59, offset: 12962},
											expr: &ruleRefExpr{
												pos:  position{line: 272, col: 60, offset: 12963},
												name: "_dcDiceType",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 272, col: 72, offset: 12975},
											name: "detailStart",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 272, col: 116, offset: 13019},
								run: (*parser).callonexprDice82,
								expr: &ruleRefExpr{
									pos:  position{line: 272, col: 116, offset: 13019},
									name: "nos",
								},
							},
							&actionExpr{
								pos: position{line: 272, col: 152, offset: 13055},
								run: (*parser).callonexprDice84,
								expr: &seqExpr{
									pos: position{line: 272, col: 152, offset: 13055},
									exprs: []any{
										&charClassMatcher{
											pos:        position{line: 272, col: 152, offset: 13055},
											val:        "[cC]",
											chars:      []rune{'c', 'C'},
											ignoreCase: false,
											inverted:   false,
										},
										&ruleRefExpr{
											pos:  position{line: 272, col: 157, offset: 13060},
											name: "nos",
										},
										&zeroOrMoreExpr{
											pos: position{line: 272, col: 161, offset: 13064},
											expr: &actionExpr{
												pos: position{line: 272, col: 163, offset: 13066},
												run: (*parser).callonexprDice89,
												expr: &seqExpr{
													pos: position{line: 272, col: 163, offset: 13066},
													exprs: []any{
														&charClassMatcher{
															pos:        position{line: 272, col: 163, offset: 13066},
															val:        "[mM]",
															chars:      []rune{'m', 'M'},
															ignoreCase: false,
															inverted:   false,
														},
														&ruleRefExpr{
															pos:  position{line: 272, col: 168, offset: 13071},
															name: "nos",
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 272, col: 210, offset: 13113},
											name: "detailEnd",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 273, col: 13, offset: 13164},
						run: (*parser).callonexprDice94,
						expr: &seqExpr{
							pos: position{line: 273, col: 13, offset: 13164},
							exprs: []any{
								&andCodeExpr{
									pos: position{line: 273, col: 13, offset: 13164},
									run: (*parser).callonexprDice96,
								},
								&andExpr{
									pos: position{line: 273, col: 52, offset: 13203},
									expr: &ruleRefExpr{
										pos:  position{line: 273, col: 53, offset: 13204},
										name: "_fateDiceType",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 273, col: 67, offset: 13218},
									name: "detailStart",
								},
								&charClassMatcher{
									pos:        position{line: 273, col: 79, offset: 13230},
									val:        "[fF]",
									chars:      []rune{'f', 'F'},
									ignoreCase: false,
									inverted:   false,
								},
								&notExpr{
									pos: position{line: 273, col: 84, offset: 13235},
									expr: &ruleRefExpr{
										pos:  position{line: 273, col: 85, offset: 13236},
										name: "xidContinue",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 273, col: 97, offset: 13248},
									name: "detailEnd",
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 274, col: 13, offset: 13301},
						name: "value",
					},
				},
			},
		},
		{
			name: "array_call",
			pos:  position{line: 276, col: 1, offset: 13308},
			expr: &choiceExpr{
				pos: position{line: 276, col: 15, offset: 13322},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 276, col: 15, offset: 13322},
						exprs: []any{
							&actionExpr{
								pos: position{line: 276, col: 15, offset: 13322},
								run: (*parser).callonarray_call3,
								expr: &litMatcher{
									pos:        position{line: 276, col: 15, offset: 13322},
									val:        "kh",
									ignoreCase: false,
									want:       "\"kh\"",
								},
							},
							&choiceExpr{
								pos: position{line: 276, col: 69, offset: 13376},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 276, col: 69, offset: 13376},
										run: (*parser).callonarray_call6,
										expr: &ruleRefExpr{
											pos:  position{line: 276, col: 69, offset: 13376},
											name: "number",
										},
									},
									&codeExpr{
										pos: position{line: 276, col: 102, offset: 13409},
										run: (*parser).callonarray_call8,
									},
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 277, col: 15, offset: 13446},
						exprs: []any{
							&actionExpr{
								pos: position{line: 277, col: 15, offset: 13446},
								run: (*parser).callonarray_call10,
								expr: &litMatcher{
									pos:        position{line: 277, col: 15, offset: 13446},
									val:        "kl",
									ignoreCase: false,
									want:       "\"kl\"",
								},
							},
							&choiceExpr{
								pos: position{line: 277, col: 69, offset: 13500},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 277, col: 69, offset: 13500},
										run: (*parser).callonarray_call13,
										expr: &ruleRefExpr{
											pos:  position{line: 277, col: 69, offset: 13500},
											name: "number",
										},
									},
									&codeExpr{
										pos: position{line: 277, col: 102, offset: 13533},
										run: (*parser).callonarray_call15,
									},
								},
							},
						},
					},
					&oneOrMoreExpr{
						pos: position{line: 278, col: 15, offset: 13570},
						expr: &actionExpr{
							pos: position{line: 278, col: 16, offset: 13571},
							run: (*parser).callonarray_call17,
							expr: &seqExpr{
								pos: position{line: 278, col: 16, offset: 13571},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 278, col: 16, offset: 13571},
										val:        "[",
										ignoreCase: false,
										want:       "\"[\"",
									},
									&ruleRefExpr{
										pos:  position{line: 278, col: 20, offset: 13575},
										name: "sp",
									},
									&ruleRefExpr{
										pos:  position{line: 278, col: 23, offset: 13578},
										name: "exprRoot",
									},
									&litMatcher{
										pos:        position{line: 278, col: 32, offset: 13587},
										val:        "]",
										ignoreCase: false,
										want:       "\"]\"",
									},
									&ruleRefExpr{
										pos:  position{line: 278, col: 36, offset: 13591},
										name: "sp",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "item_getX",
			pos:  position{line: 283, col: 1, offset: 13891},
			expr: &zeroOrMoreExpr{
				pos: position{line: 283, col: 14, offset: 13904},
				expr: &seqExpr{
					pos: position{line: 283, col: 15, offset: 13905},
					exprs: []any{
						&actionExpr{
							pos: position{line: 283, col: 15, offset: 13905},
							run: (*parser).callonitem_getX3,
							expr: &seqExpr{
								pos: position{line: 283, col: 15, offset: 13905},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 283, col: 15, offset: 13905},
										val:        "[",
										ignoreCase: false,
										want:       "\"[\"",
									},
									&ruleRefExpr{
										pos:  position{line: 283, col: 19, offset: 13909},
										name: "sp",
									},
									&ruleRefExpr{
										pos:  position{line: 283, col: 22, offset: 13912},
										name: "exprRoot",
									},
									&ruleRefExpr{
										pos:  position{line: 283, col: 31, offset: 13921},
										name: "sp",
									},
									&litMatcher{
										pos:        position{line: 283, col: 34, offset: 13924},
										val:        "]",
										ignoreCase: false,
										want:       "\"]\"",
									},
									&ruleRefExpr{
										pos:  position{line: 283, col: 38, offset: 13928},
										name: "sp",
									},
									&notExpr{
										pos: position{line: 283, col: 42, offset: 13932},
										expr: &litMatcher{
											pos:        position{line: 283, col: 43, offset: 13933},
											val:        "=",
											ignoreCase: false,
											want:       "\"=\"",
										},
									},
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 283, col: 79, offset: 13969},
							expr: &ruleRefExpr{
								pos:  position{line: 283, col: 79, offset: 13969},
								name: "func_invoke",
							},
						},
					},
				},
			},
		},
		{
			name: "item_get",
			pos:  position{line: 284, col: 1, offset: 13985},
			expr: &zeroOrOneExpr{
				pos: position{line: 284, col: 13, offset: 13997},
				expr: &seqExpr{
					pos: position{line: 284, col: 14, offset: 13998},
					exprs: []any{
						&andLogicalExpr{
							pos: position{line: 284, col: 14, offset: 13998},
							expr: &ruleRefExpr{
								pos:  position{line: 284, col: 17, offset: 14001},
								name: "item_getX",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 284, col: 28, offset: 14012},
							name: "item_getX",
						},
					},
				},
			},
		},
		{
			name: "attr_getX",
			pos:  position{line: 286, col: 1, offset: 14025},
			expr: &zeroOrMoreExpr{
				pos: position{line: 286, col: 14, offset: 14038},
				expr: &seqExpr{
					pos: position{line: 286, col: 15, offset: 14039},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 286, col: 15, offset: 14039},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&actionExpr{
							pos: position{line: 286, col: 20, offset: 14044},
							run: (*parser).callonattr_getX4,
							expr: &seqExpr{
								pos: position{line: 286, col: 20, offset: 14044},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 286, col: 20, offset: 14044},
										name: "sp",
									},
									&labeledExpr{
										pos:   position{line: 286, col: 23, offset: 14047},
										label: "id",
										expr: &ruleRefExpr{
											pos:  position{line: 286, col: 26, offset: 14050},
											name: "identifier",
										},
									},
									&ruleRefExpr{
										pos:  position{line: 286, col: 37, offset: 14061},
										name: "sp",
									},
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 286, col: 88, offset: 14112},
							expr: &ruleRefExpr{
								pos:  position{line: 286, col: 88, offset: 14112},
								name: "func_invoke",
							},
						},
					},
				},
			},
		},
		{
			name: "attr_get",
			pos:  position{line: 287, col: 1, offset: 14128},
			expr: &zeroOrOneExpr{
				pos: position{line: 287, col: 13, offset: 14140},
				expr: &seqExpr{
					pos: position{line: 287, col: 14, offset: 14141},
					exprs: []any{
						&andLogicalExpr{
							pos: position{line: 287, col: 14, offset: 14141},
							expr: &ruleRefExpr{
								pos:  position{line: 287, col: 16, offset: 14143},
								name: "attr_getX",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 287, col: 26, offset: 14153},
							name: "attr_getX",
						},
					},
				},
			},
		},
		{
			name: "func_invoke",
			pos:  position{line: 289, col: 1, offset: 14166},
			expr: &choiceExpr{
				pos: position{line: 289, col: 16, offset: 14181},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 289, col: 16, offset: 14181},
						run: (*parser).callonfunc_invoke2,
						expr: &seqExpr{
							pos: position{line: 289, col: 16, offset: 14181},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 289, col: 16, offset: 14181},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&ruleRefExpr{
									pos:  position{line: 289, col: 20, offset: 14185},
									name: "sp",
								},
								&litMatcher{
									pos:        position{line: 289, col: 23, offset: 14188},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
								&ruleRefExpr{
									pos:  position{line: 289, col: 27, offset: 14192},
									name: "sp",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 290, col: 16, offset: 14234},
						exprs: []any{
							&actionExpr{
								pos: position{line: 290, col: 16, offset: 14234},
								run: (*parser).callonfunc_invoke9,
								expr: &seqExpr{
									pos: position{line: 290, col: 16, offset: 14234},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 290, col: 16, offset: 14234},
											val:        "(",
											ignoreCase: false,
											want:       "\"(\"",
										},
										&ruleRefExpr{
											pos:  position{line: 290, col: 20, offset: 14238},
											name: "sp",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 290, col: 70, offset: 14288},
								run: (*parser).callonfunc_invoke13,
								expr: &seqExpr{
									pos: position{line: 290, col: 70, offset: 14288},
									exprs: []any{
										&ruleRefExpr{
											pos:  position{line: 290, col: 70, offset: 14288},
											name: "exprRoot",
										},
										&zeroOrMoreExpr{
											pos: position{line: 290, col: 79, offset: 14297},
											expr: &actionExpr{
												pos: position{line: 290, col: 80, offset: 14298},
												run: (*parser).callonfunc_invoke17,
												expr: &seqExpr{
													pos: position{line: 290, col: 80, offset: 14298},
													exprs: []any{
														&litMatcher{
															pos:        position{line: 290, col: 80, offset: 14298},
															val:        ",",
															ignoreCase: false,
															want:       "\",\"",
														},
														&ruleRefExpr{
															pos:  position{line: 290, col: 84, offset: 14302},
															name: "sp",
														},
														&ruleRefExpr{
															pos:  position{line: 290, col: 87, offset: 14305},
															name: "exprRoot",
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 290, col: 122, offset: 14340},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
										&ruleRefExpr{
											pos:  position{line: 290, col: 126, offset: 14344},
											name: "sp",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "dict_item",
			pos:  position{line: 292, col: 1, offset: 14390},
			expr: &actionExpr{
				pos: position{line: 292, col: 14, offset: 14403},
				run: (*parser).callondict_item1,
				expr: &seqExpr{
					pos: position{line: 292, col: 14, offset: 14403},
					exprs: []any{
						&seqExpr{
							pos: position{line: 292, col: 15, offset: 14404},
							exprs: []any{
								&choiceExpr{
									pos: position{line: 292, col: 16, offset: 14405},
									alternatives: []any{
										&ruleRefExpr{
											pos:  position{line: 292, col: 16, offset: 14405},
											name: "value_id_without_colon",
										},
										&ruleRefExpr{
											pos:  position{line: 292, col: 41, offset: 14430},
											name: "exprRoot",
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 292, col: 51, offset: 14440},
									name: "sp",
								},
								&litMatcher{
									pos:        position{line: 292, col: 54, offset: 14443},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&ruleRefExpr{
									pos:  position{line: 292, col: 58, offset: 14447},
									name: "sp",
								},
								&ruleRefExpr{
									pos:  position{line: 292, col: 61, offset: 14450},
									name: "exprRoot",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 292, col: 71, offset: 14460},
							name: "sp",
						},
					},
				},
			},
		},
		{
			name: "value_id_without_colon",
			pos:  position{line: 295, col: 1, offset: 14499},
			expr: &seqExpr{
				pos: position{line: 295, col: 27, offset: 14525},
				exprs: []any{
					&actionExpr{
						pos: position{line: 295, col: 27, offset: 14525},
						run: (*parser).callonvalue_id_without_colon2,
						expr: &seqExpr{
							pos: position{line: 295, col: 27, offset: 14525},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 295, col: 27, offset: 14525},
									label: "id",
									expr: &ruleRefExpr{
										pos:  position{line: 295, col: 30, offset: 14528},
										name: "identifierWithoutColon",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 295, col: 53, offset: 14551},
									name: "sp",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 295, col: 112, offset: 14610},
						exprs: []any{
							&zeroOrOneExpr{
								pos: position{line: 295, col: 112, offset: 14610},
								expr: &ruleRefExpr{
									pos:  position{line: 295, col: 112, offset: 14610},
									name: "func_invoke",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 295, col: 125, offset: 14623},
								name: "item_get",
							},
							&ruleRefExpr{
								pos:  position{line: 295, col: 134, offset: 14632},
								name: "attr_get",
							},
						},
					},
				},
			},
		},
		{
			name: "value_array_range",
			pos:  position{line: 297, col: 1, offset: 14642},
			expr: &actionExpr{
				pos: position{line: 297, col: 22, offset: 14663},
				run: (*parser).callonvalue_array_range1,
				expr: &seqExpr{
					pos: position{line: 297, col: 22, offset: 14663},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 297, col: 22, offset: 14663},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&ruleRefExpr{
							pos:  position{line: 297, col: 26, offset: 14667},
							name: "sp",
						},
						&ruleRefExpr{
							pos:  position{line: 297, col: 29, offset: 14670},
							name: "exprRoot",
						},
						&litMatcher{
							pos:        position{line: 297, col: 38, offset: 14679},
							val:        "..",
							ignoreCase: false,
							want:       "\"..\"",
						},
						&ruleRefExpr{
							pos:  position{line: 297, col: 43, offset: 14684},
							name: "sp",
						},
						&ruleRefExpr{
							pos:  position{line: 297, col: 46, offset: 14687},
							name: "exprRoot",
						},
						&litMatcher{
							pos:        position{line: 297, col: 55, offset: 14696},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
						&ruleRefExpr{
							pos:  position{line: 297, col: 59, offset: 14700},
							name: "sp",
						},
					},
				},
			},
		},
		{
			name: "value_array",
			pos:  position{line: 298, col: 1, offset: 14735},
			expr: &seqExpr{
				pos: position{line: 298, col: 16, offset: 14750},
				exprs: []any{
					&actionExpr{
						pos: position{line: 298, col: 16, offset: 14750},
						run: (*parser).callonvalue_array2,
						expr: &seqExpr{
							pos: position{line: 298, col: 16, offset: 14750},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 298, col: 16, offset: 14750},
									val:        "[",
									ignoreCase: false,
									want:       "\"[\"",
								},
								&ruleRefExpr{
									pos:  position{line: 298, col: 20, offset: 14754},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 298, col: 70, offset: 14804},
						run: (*parser).callonvalue_array6,
						expr: &seqExpr{
							pos: position{line: 298, col: 70, offset: 14804},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 298, col: 70, offset: 14804},
									name: "exprRoot",
								},
								&zeroOrMoreExpr{
									pos: position{line: 298, col: 79, offset: 14813},
									expr: &actionExpr{
										pos: position{line: 298, col: 80, offset: 14814},
										run: (*parser).callonvalue_array10,
										expr: &seqExpr{
											pos: position{line: 298, col: 80, offset: 14814},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 298, col: 80, offset: 14814},
													val:        ",",
													ignoreCase: false,
													want:       "\",\"",
												},
												&ruleRefExpr{
													pos:  position{line: 298, col: 84, offset: 14818},
													name: "sp",
												},
												&ruleRefExpr{
													pos:  position{line: 298, col: 87, offset: 14821},
													name: "exprRoot",
												},
											},
										},
									},
								},
								&litMatcher{
									pos:        position{line: 298, col: 122, offset: 14856},
									val:        "]",
									ignoreCase: false,
									want:       "\"]\"",
								},
								&ruleRefExpr{
									pos:  position{line: 298, col: 126, offset: 14860},
									name: "sp",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "value",
			pos:  position{line: 300, col: 1, offset: 14906},
			expr: &choiceExpr{
				pos: position{line: 300, col: 10, offset: 14915},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 300, col: 10, offset: 14915},
						run: (*parser).callonvalue2,
						expr: &seqExpr{
							pos: position{line: 300, col: 10, offset: 14915},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 300, col: 10, offset: 14915},
									val:        "true",
									ignoreCase: false,
									want:       "\"true\"",
								},
								&ruleRefExpr{
									pos:  position{line: 300, col: 17, offset: 14922},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 301, col: 10, offset: 14965},
						run: (*parser).callonvalue6,
						expr: &seqExpr{
							pos: position{line: 301, col: 10, offset: 14965},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 301, col: 10, offset: 14965},
									val:        "false",
									ignoreCase: false,
									want:       "\"false\"",
								},
								&ruleRefExpr{
									pos:  position{line: 301, col: 18, offset: 14973},
									name: "sp",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 302, col: 10, offset: 15016},
						run: (*parser).callonvalue10,
						expr: &seqExpr{
							pos: position{line: 302, col: 10, offset: 15016},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 302, col: 10, offset: 15016},
									val:        "undefined",
									ignoreCase: false,
									want:       "\"undefined\"",
								},
								&ruleRefExpr{
									pos:  position{line: 302, col: 22, offset: 15028},
									name: "sp",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 303, col: 10, offset: 15067},
						exprs: []any{
							&actionExpr{
								pos: position{line: 303, col: 10, offset: 15067},
								run: (*parser).callonvalue15,
								expr: &seqExpr{
									pos: position{line: 303, col: 10, offset: 15067},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 303, col: 10, offset: 15067},
											val:        "this",
											ignoreCase: false,
											want:       "\"this\"",
										},
										&ruleRefExpr{
											pos:  position{line: 303, col: 17, offset: 15074},
											name: "sp",
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 303, col: 42, offset: 15099},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 303, col: 42, offset: 15099},
										name: "item_get",
									},
									&ruleRefExpr{
										pos:  position{line: 303, col: 51, offset: 15108},
										name: "attr_get",
									},
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 304, col: 10, offset: 15126},
						exprs: []any{
							&actionExpr{
								pos: position{line: 304, col: 10, offset: 15126},
								run: (*parser).callonvalue23,
								expr: &seqExpr{
									pos: position{line: 304, col: 10, offset: 15126},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 304, col: 10, offset: 15126},
											val:        "&",
											ignoreCase: false,
											want:       "\"&\"",
										},
										&labeledExpr{
											pos:   position{line: 304, col: 14, offset: 15130},
											label: "id",
											expr: &ruleRefExpr{
												pos:  position{line: 304, col: 17, offset: 15133},
												name: "identifier",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 304, col: 28, offset: 15144},
											name: "sp",
										},
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 304, col: 83, offset: 15199},
								name: "attr_get",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 306, col: 10, offset: 15218},
						name: "float",
					},
					&ruleRefExpr{
						pos:  position{line: 307, col: 10, offset: 15233},
						name: "number",
					},
					&seqExpr{
						pos: position{line: 310, col: 10, offset: 15267},
						exprs: []any{
							&actionExpr{
								pos: position{line: 310, col: 10, offset: 15267},
								run: (*parser).callonvalue33,
								expr: &seqExpr{
									pos: position{line: 310, col: 10, offset: 15267},
									exprs: []any{
										&andExpr{
											pos: position{line: 310, col: 10, offset: 15267},
											expr: &seqExpr{
												pos: position{line: 310, col: 12, offset: 15269},
												exprs: []any{
													&ruleRefExpr{
														pos:  position{line: 310, col: 12, offset: 15269},
														name: "identifier",
													},
													&ruleRefExpr{
														pos:  position{line: 310, col: 23, offset: 15280},
														name: "spNoCR",
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 310, col: 31, offset: 15288},
											name: "detailStart",
										},
										&labeledExpr{
											pos:   position{line: 310, col: 43, offset: 15300},
											label: "id",
											expr: &ruleRefExpr{
												pos:  position{line: 310, col: 46, offset: 15303},
												name: "identifier",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 310, col: 57, offset: 15314},
											name: "detailEnd",
										},
										&ruleRefExpr{
											pos:  position{line: 310, col: 67, offset: 15324},
											name: "spNoCR",
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 310, col: 133, offset: 15390},
								exprs: []any{
									&zeroOrOneExpr{
										pos: position{line: 310, col: 133, offset: 15390},
										expr: &ruleRefExpr{
											pos:  position{line: 310, col: 133, offset: 15390},
											name: "func_invoke",
										},
									},
									&ruleRefExpr{
										pos:  position{line: 310, col: 146, offset: 15403},
										name: "item_get",
									},
									&ruleRefExpr{
										pos:  position{line: 310, col: 155, offset: 15412},
										name: "attr_get",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 312, col: 10, offset: 15431},
						name: "fstring",
					},
					&seqExpr{
						pos: position{line: 313, col: 10, offset: 15448},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 313, col: 10, offset: 15448},
								name: "sub",
							},
							&ruleRefExpr{
								pos:  position{line: 313, col: 14, offset: 15452},
								name: "item_get",
							},
							&ruleRefExpr{
								pos:  position{line: 313, col: 23, offset: 15461},
								name: "attr_get",
							},
						},
					},
					&seqExpr{
						pos: position{line: 314, col: 10, offset: 15479},
						exprs: []any{
							&actionExpr{
								pos: position{line: 314, col: 10, offset: 15479},
								run: (*parser).callonvalue55,
								expr: &seqExpr{
									pos: position{line: 314, col: 10, offset: 15479},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 314, col: 10, offset: 15479},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
										&ruleRefExpr{
											pos:  position{line: 314, col: 14, offset: 15483},
											name: "sp",
										},
										&litMatcher{
											pos:        position{line: 314, col: 17, offset: 15486},
											val:        "]",
											ignoreCase: false,
											want:       "\"]\"",
										},
										&ruleRefExpr{
											pos:  position{line: 314, col: 21, offset: 15490},
											name: "sp",
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 314, col: 48, offset: 15517},
								exprs: []any{
									&zeroOrOneExpr{
										pos: position{line: 314, col: 48, offset: 15517},
										expr: &ruleRefExpr{
											pos:  position{line: 314, col: 48, offset: 15517},
											name: "array_call",
										},
									},
									&ruleRefExpr{
										pos:  position{line: 314, col: 60, offset: 15529},
										name: "attr_get",
									},
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 315, col: 10, offset: 15547},
						exprs: []any{
							&andExpr{
								pos: position{line: 315, col: 10, offset: 15547},
								expr: &ruleRefExpr{
									pos:  position{line: 315, col: 11, offset: 15548},
									name: "value_array_range",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 315, col: 29, offset: 15566},
								name: "value_array_range",
							},
							&zeroOrOneExpr{
								pos: position{line: 315, col: 47, offset: 15584},
								expr: &ruleRefExpr{
									pos:  position{line: 315, col: 47, offset: 15584},
									name: "array_call",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 315, col: 59, offset: 15596},
								name: "attr_get",
							},
						},
					},
					&seqExpr{
						pos: position{line: 316, col: 10, offset: 15614},
						exprs: []any{
							&andExpr{
								pos: position{line: 316, col: 10, offset: 15614},
								expr: &ruleRefExpr{
									pos:  position{line: 316, col: 11, offset: 15615},
									name: "value_array",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 316, col: 23, offset: 15627},
								name: "value_array",
							},
							&zeroOrOneExpr{
								pos: position{line: 316, col: 35, offset: 15639},
								expr: &ruleRefExpr{
									pos:  position{line: 316, col: 35, offset: 15639},
									name: "array_call",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 316, col: 47, offset: 15651},
								name: "attr_get",
							},
						},
					},
					&seqExpr{
						pos: position{line: 317, col: 10, offset: 15669},
						exprs: []any{
							&actionExpr{
								pos: position{line: 317, col: 10, offset: 15669},
								run: (*parser).callonvalue80,
								expr: &seqExpr{
									pos: position{line: 317, col: 10, offset: 15669},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 317, col: 10, offset: 15669},
											val:        "{",
											ignoreCase: false,
											want:       "\"{\"",
										},
										&ruleRefExpr{
											pos:  position{line: 317, col: 14, offset: 15673},
											name: "sp",
										},
										&litMatcher{
											pos:        position{line: 317, col: 17, offset: 15676},
											val:        "}",
											ignoreCase: false,
											want:       "\"}\"",
										},
										&ruleRefExpr{
											pos:  position{line: 317, col: 21, offset: 15680},
											name: "sp",
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 317, col: 47, offset: 15706},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 317, col: 47, offset: 15706},
										name: "item_get",
									},
									&ruleRefExpr{
										pos:  position{line: 317, col: 56, offset: 15715},
										name: "attr_get",
									},
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 318, col: 10, offset: 15733},
						exprs: []any{
							&actionExpr{
								pos: position{line: 318, col: 10, offset: 15733},
								run: (*parser).callonvalue90,
								expr: &seqExpr{
									pos: position{line: 318, col: 10, offset: 15733},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 318, col: 10, offset: 15733},
											val:        "{",
											ignoreCase: false,
											want:       "\"{\"",
										},
										&ruleRefExpr{
											pos:  position{line: 318, col: 14, offset: 15737},
											name: "sp",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 318, col: 42, offset: 15765},
								run: (*parser).callonvalue94,
								expr: &seqExpr{
									pos: position{line: 318, col: 42, offset: 15765},
									exprs: []any{
										&ruleRefExpr{
											pos:  position{line: 318, col: 42, offset: 15765},
											name: "dict_item",
										},
										&zeroOrMoreExpr{
											pos: position{line: 318, col: 52, offset: 15775},
											expr: &seqExpr{
												pos: position{line: 318, col: 53, offset: 15776},
												exprs: []any{
													&litMatcher{
														pos:        position{line: 318, col: 53, offset: 15776},
														val:        ",",
														ignoreCase: false,
														want:       "\",\"",
													},
													&ruleRefExpr{
														pos:  position{line: 318, col: 57, offset: 15780},
														name: "sp",
													},
													&ruleRefExpr{
														pos:  position{line: 318, col: 60, offset: 15783},
														name: "dict_item",
													},
												},
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 318, col: 73, offset: 15796},
											expr: &litMatcher{
												pos:        position{line: 318, col: 73, offset: 15796},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
										&litMatcher{
											pos:        position{line: 318, col: 78, offset: 15801},
											val:        "}",
											ignoreCase: false,
											want:       "\"}\"",
										},
										&ruleRefExpr{
											pos:  position{line: 318, col: 82, offset: 15805},
											name: "sp",
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 318, col: 126, offset: 15849},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 318, col: 126, offset: 15849},
										name: "item_get",
									},
									&ruleRefExpr{
										pos:  position{line: 318, col: 135, offset: 15858},
										name: "attr_get",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "number",
			pos:  position{line: 321, col: 1, offset: 15878},
			expr: &actionExpr{
				pos: position{line: 321, col: 11, offset: 15888},
				run: (*parser).callonnumber1,
				expr: &oneOrMoreExpr{
					pos: position{line: 321, col: 11, offset: 15888},
					expr: &charClassMatcher{
						pos:        position{line: 321, col: 11, offset: 15888},
						val:        "[0-9]",
						ranges:     []rune{'0', '9'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "float",
			pos:  position{line: 322, col: 1, offset: 15936},
			expr: &actionExpr{
				pos: position{line: 322, col: 10, offset: 15945},
				run: (*parser).callonfloat1,
				expr: &seqExpr{
					pos: position{line: 322, col: 10, offset: 15945},
					exprs: []any{
						&zeroOrMoreExpr{
							pos: position{line: 322, col: 10, offset: 15945},
							expr: &charClassMatcher{
								pos:        position{line: 322, col: 10, offset: 15945},
								val:        "[0-9]",
								ranges:     []rune{'0', '9'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&litMatcher{
							pos:        position{line: 322, col: 17, offset: 15952},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&oneOrMoreExpr{
							pos: position{line: 322, col: 21, offset: 15956},
							expr: &charClassMatcher{
								pos:        position{line: 322, col: 21, offset: 15956},
								val:        "[0-9]",
								ranges:     []rune{'0', '9'},
								ignoreCase: false,
								inverted:   false,
							},
						},
					},
				},
			},
		},
		{
			name: "strPart",
			pos:  position{line: 325, col: 1, offset: 16020},
			expr: &actionExpr{
				pos: position{line: 325, col: 12, offset: 16031},
				run: (*parser).callonstrPart1,
				expr: &labeledExpr{
					pos:   position{line: 325, col: 12, offset: 16031},
					label: "text",
					expr: &oneOrMoreExpr{
						pos: position{line: 325, col: 19, offset: 16038},
						expr: &choiceExpr{
							pos: position{line: 325, col: 20, offset: 16039},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 325, col: 20, offset: 16039},
									name: "escape",
								},
								&seqExpr{
									pos: position{line: 325, col: 30, offset: 16049},
									exprs: []any{
										&notExpr{
											pos: position{line: 325, col: 30, offset: 16049},
											expr: &charClassMatcher{
												pos:        position{line: 325, col: 31, offset: 16050},
												val:        "[{`\\\\]",
												chars:      []rune{'{', '`', '\\'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&anyMatcher{
											line: 325, col: 37, offset: 16056,
										},
									},
								},
							},
						},
					},
					textCapture: true,
				},
			},
		},
		{
			name: "strPart1",
			pos:  position{line: 326, col: 1, offset: 16119},
			expr: &actionExpr{
				pos: position{line: 326, col: 13, offset: 16131},
				run: (*parser).callonstrPart11,
				expr: &labeledExpr{
					pos:   position{line: 326, col: 13, offset: 16131},
					label: "text",
					expr: &oneOrMoreExpr{
						pos: position{line: 326, col: 20, offset: 16138},
						expr: &choiceExpr{
							pos: position{line: 326, col: 21, offset: 16139},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 326, col: 21, offset: 16139},
									name: "escape",
								},
								&seqExpr{
									pos: position{line: 326, col: 31, offset: 16149},
									exprs: []any{
										&notExpr{
											pos: position{line: 326, col: 31, offset: 16149},
											expr: &charClassMatcher{
												pos:        position{line: 326, col: 32, offset: 16150},
												val:        "[{\\x1e\\\\]",
												chars:      []rune{'{', '\x1e', '\\'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&anyMatcher{
											line: 326, col: 41, offset: 16159,
										},
									},
								},
							},
						},
					},
					textCapture: true,
				},
			},
		},
		{
			name: "strPart2",
			pos:  position{line: 327, col: 1, offset: 16222},
			expr: &actionExpr{
				pos: position{line: 327, col: 13, offset: 16234},
				run: (*parser).callonstrPart21,
				expr: &labeledExpr{
					pos:   position{line: 327, col: 13, offset: 16234},
					label: "text",
					expr: &oneOrMoreExpr{
						pos: position{line: 327, col: 20, offset: 16241},
						expr: &choiceExpr{
							pos: position{line: 327, col: 21, offset: 16242},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 327, col: 21, offset: 16242},
									name: "escape",
								},
								&seqExpr{
									pos: position{line: 327, col: 31, offset: 16252},
									exprs: []any{
										&notExpr{
											pos: position{line: 327, col: 31, offset: 16252},
											expr: &charClassMatcher{
												pos:        position{line: 327, col: 32, offset: 16253},
												val:        "[{\"\\\\\\n\\r]",
												chars:      []rune{'{', '"', '\\', '\n', '\r'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&anyMatcher{
											line: 327, col: 42, offset: 16263,
										},
									},
								},
							},
						},
					},
					textCapture: true,
				},
			},
		},
		{
			name: "strPart3",
			pos:  position{line: 328, col: 1, offset: 16326},
			expr: &actionExpr{
				pos: position{line: 328, col: 13, offset: 16338},
				run: (*parser).callonstrPart31,
				expr: &labeledExpr{
					pos:   position{line: 328, col: 13, offset: 16338},
					label: "text",
					expr: &oneOrMoreExpr{
						pos: position{line: 328, col: 20, offset: 16345},
						expr: &choiceExpr{
							pos: position{line: 328, col: 21, offset: 16346},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 328, col: 21, offset: 16346},
									name: "escape",
								},
								&seqExpr{
									pos: position{line: 328, col: 31, offset: 16356},
									exprs: []any{
										&notExpr{
											pos: position{line: 328, col: 31, offset: 16356},
											expr: &charClassMatcher{
												pos:        position{line: 328, col: 32, offset: 16357},
												val:        "[{'\\\\\\n\\r]",
												chars:      []rune{'{', '\'', '\\', '\n', '\r'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&anyMatcher{
											line: 328, col: 42, offset: 16367,
										},
									},
								},
							},
						},
					},
					textCapture: true,
				},
			},
		},
		{
			name: "fstring",
			pos:  position{line: 330, col: 1, offset: 16431},
			expr: &seqExpr{
				pos: position{line: 330, col: 12, offset: 16442},
				exprs: []any{
					&choiceExpr{
						pos: position{line: 331, col: 9, offset: 16452},
						alternatives: []any{
							&actionExpr{
								pos: position{line: 331, col: 10, offset: 16453},
								run: (*parser).callonfstring3,
								expr: &seqExpr{
									pos: position{line: 331, col: 10, offset: 16453},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 331, col: 10, offset: 16453},
											val:        "'",
											ignoreCase: false,
											want:       "\"'\"",
										},
										&litMatcher{
											pos:        position{line: 331, col: 15, offset: 16458},
											val:        "'",
											ignoreCase: false,
											want:       "\"'\"",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 332, col: 10, offset: 16496},
								run: (*parser).callonfstring7,
								expr: &seqExpr{
									pos: position{line: 332, col: 10, offset: 16496},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 332, col: 10, offset: 16496},
											val:        "\x1e",
											ignoreCase: false,
											want:       "\"\\x1e\"",
										},
										&litMatcher{
											pos:        position{line: 332, col: 17, offset: 16503},
											val:        "\x1e",
											ignoreCase: false,
											want:       "\"\\x1e\"",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 333, col: 10, offset: 16543},
								run: (*parser).callonfstring11,
								expr: &seqExpr{
									pos: position{line: 333, col: 10, offset: 16543},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 333, col: 10, offset: 16543},
											val:        "\"",
											ignoreCase: false,
											want:       "\"\\\"\"",
										},
										&litMatcher{
											pos:        position{line: 333, col: 14, offset: 16547},
											val:        "\"",
											ignoreCase: false,
											want:       "\"\\\"\"",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 334, col: 10, offset: 16584},
								run: (*parser).callonfstring15,
								expr: &seqExpr{
									pos: position{line: 334, col: 10, offset: 16584},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 334, col: 10, offset: 16584},
											val:        "`",
											ignoreCase: false,
											want:       "\"`\"",
										},
										&litMatcher{
											pos:        position{line: 334, col: 14, offset: 16588},
											val:        "`",
											ignoreCase: false,
											want:       "\"`\"",
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 335, col: 10, offset: 16625},
								exprs: []any{
									&actionExpr{
										pos: position{line: 335, col: 10, offset: 16625},
										run: (*parser).callonfstring20,
										expr: &litMatcher{
											pos:        position{line: 335, col: 10, offset: 16625},
											val:        "`",
											ignoreCase: false,
											want:       "\"`\"",
										},
									},
									&actionExpr{
										pos: position{line: 335, col: 39, offset: 16654},
										run: (*parser).callonfstring22,
										expr: &seqExpr{
											pos: position{line: 335, col: 39, offset: 16654},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 335, col: 39, offset: 16654},
													expr: &choiceExpr{
														pos: position{line: 335, col: 41, offset: 16656},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 335, col: 42, offset: 16657},
																exprs: []any{
																	&actionExpr{
																		pos: position{line: 335, col: 42, offset: 16657},
																		run: (*parser).callonfstring27,
																		expr: &seqExpr{
																			pos: position{line: 335, col: 42, offset: 16657},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 335, col: 42, offset: 16657},
																					val:        "{",
																					ignoreCase: false,
																					want:       "\"{\"",
																				},
																				&ruleRefExpr{
																					pos:  position{line: 335, col: 46, offset: 16661},
																					name: "sp",
																				},
																				&ruleRefExpr{
																					pos:  position{line: 335, col: 49, offset: 16664},
																					name: "exprRoot",
																				},
																			},
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 335, col: 81, offset: 16696},
																		val:        "}",
																		ignoreCase: false,
																		want:       "\"}\"",
																	},
																},
															},
															&seqExpr{
																pos: position{line: 335, col: 89, offset: 16704},
																exprs: []any{
																	&actionExpr{
																		pos: position{line: 335, col: 89, offset: 16704},
																		run: (*parser).callonfstring34,
																		expr: &seqExpr{
																			pos: position{line: 335, col: 89, offset: 16704},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 335, col: 89, offset: 16704},
																					val:        "{%",
																					ignoreCase: false,
																					want:       "\"{%\"",
																				},
																				&ruleRefExpr{
																					pos:  position{line: 335, col: 94, offset: 16709},
																					name: "sp",
																				},
																				&ruleRefExpr{
																					pos:  position{line: 335, col: 97, offset: 16712},
																					name: "exprRoot",
																				},
																			},
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 335, col: 129, offset: 16744},
																		val:        "%}",
																		ignoreCase: false,
																		want:       "\"%}\"",
																	},
																},
															},
															&ruleRefExpr{
																pos:  position{line: 335, col: 137, offset: 16752},
																name: "strPart",
															},
														},
													},
												},
												&litMatcher{
													pos:        position{line: 335, col: 148, offset: 16763},
													val:        "`",
													ignoreCase: false,
													want:       "\"`\"",
												},
											},
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 336, col: 10, offset: 16825},
								exprs: []any{
									&actionExpr{
										pos: position{line: 336, col: 10, offset: 16825},
										run: (*parser).callonfstring43,
										expr: &litMatcher{
											pos:        position{line: 336, col: 10, offset: 16825},
											val:        "\x1e",
											ignoreCase: false,
											want:       "\"\\x1e\"",
										},
									},
									&actionExpr{
										pos: position{line: 336, col: 42, offset: 16857},
										run: (*parser).callonfstring45,
										expr: &seqExpr{
											pos: position{line: 336, col: 42, offset: 16857},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 336, col: 42, offset: 16857},
													expr: &choiceExpr{
														pos: position{line: 336, col: 44, offset: 16859},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 336, col: 45, offset: 16860},
																exprs: []any{
																	&actionExpr{
																		pos: position{line: 336, col: 45, offset: 16860},
																		run: (*parser).callonfstring50,
																		expr: &seqExpr{
																			pos: position{line: 336, col: 45, offset: 16860},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 336, col: 45, offset: 16860},
																					val:        "{",
																					ignoreCase: false,
																					want:       "\"{\"",
																				},
																				&ruleRefExpr{
																					pos:  position{line: 336, col: 49, offset: 16864},
																					name: "sp",
																				},
																				&ruleRefExpr{
																					pos:  position{line: 336, col: 52, offset: 16867},
																					name: "exprRoot",
																				},
																			},
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 336, col: 84, offset: 16899},
																		val:        "}",
																		ignoreCase: false,
																		want:       "\"}\"",
																	},
																},
															},
															&seqExpr{
																pos: position{line: 336, col: 92, offset: 16907},
																exprs: []any{
																	&actionExpr{
																		pos: position{line: 336, col: 92, offset: 16907},
																		run: (*parser).callonfstring57,
																		expr: &seqExpr{
																			pos: position{line: 336, col: 92, offset: 16907},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 336, col: 92, offset: 16907},
																					val:        "{%",
																					ignoreCase: false,
																					want:       "\"{%\"",
																				},
																				&ruleRefExpr{
																					pos:  position{line: 336, col: 97, offset: 16912},
																					name: "sp",
																				},
																				&ruleRefExpr{
																					pos:  position{line: 336, col: 100, offset: 16915},
																					name: "exprRoot",
																				},
																			},
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 336, col: 132, offset: 16947},
																		val:        "%}",
																		ignoreCase: false,
																		want:       "\"%}\"",
																	},
																},
															},
															&ruleRefExpr{
																pos:  position{line: 336, col: 140, offset: 16955},
																name: "strPart1",
															},
														},
													},
												},
												&litMatcher{
													pos:        position{line: 336, col: 152, offset: 16967},
													val:        "\x1e",
													ignoreCase: false,
													want:       "\"\\x1e\"",
												},
											},
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 337, col: 10, offset: 17053},
								exprs: []any{
									&actionExpr{
										pos: position{line: 337, col: 10, offset: 17053},
										run: (*parser).callonfstring66,
										expr: &litMatcher{
											pos:        position{line: 337, col: 10, offset: 17053},
											val:        "\"",
											ignoreCase: false,
											want:       "\"\\\"\"",
										},
									},
									&actionExpr{
										pos: position{line: 337, col: 39, offset: 17082},
										run: (*parser).callonfstring68,
										expr: &seqExpr{
											pos: position{line: 337, col: 39, offset: 17082},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 337, col: 39, offset: 17082},
													expr: &ruleRefExpr{
														pos:  position{line: 337, col: 39, offset: 17082},
														name: "strPart2",
													},
												},
												&litMatcher{
													pos:        position{line: 337, col: 49, offset: 17092},
													val:        "\"",
													ignoreCase: false,
													want:       "\"\\\"\"",
												},
											},
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 338, col: 10, offset: 17130},
								exprs: []any{
									&actionExpr{
										pos: position{line: 338, col: 10, offset: 17130},
										run: (*parser).callonfstring74,
										expr: &litMatcher{
											pos:        position{line: 338, col: 10, offset: 17130},
											val:        "'",
											ignoreCase: false,
											want:       "\"'\"",
										},
									},
									&actionExpr{
										pos: position{line: 338, col: 40, offset: 17160},
										run: (*parser).callonfstring76,
										expr: &seqExpr{
											pos: position{line: 338, col: 40, offset: 17160},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 338, col: 40, offset: 17160},
													expr: &ruleRefExpr{
														pos:  position{line: 338, col: 40, offset: 17160},
														name: "strPart3",
													},
												},
												&litMatcher{
													pos:        position{line: 338, col: 50, offset: 17170},
													val:        "'",
													ignoreCase: false,
													want:       "\"'\"",
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 339, col: 7, offset: 17207},
						name: "sp",
					},
				},
			},
		},
		{
			name: "escape",
			pos:  position{line: 341, col: 1, offset: 17211},
			expr: &seqExpr{
				pos: position{line: 341, col: 11, offset: 17221},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 341, col: 11, offset: 17221},
						val:        "\\",
						ignoreCase: false,
						want:       "\"\\\\\"",
					},
					&charClassMatcher{
						pos:        position{line: 341, col: 17, offset: 17227},
						val:        "[btnfr\"'\\\\]",
						chars:      []rune{'b', 't', 'n', 'f', 'r', '"', '\'', '\\'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "keywords",
			pos:  position{line: 345, col: 1, offset: 17276},
			expr: &choiceExpr{
				pos: position{line: 345, col: 13, offset: 17288},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 345, col: 13, offset: 17288},
						val:        "while",
						ignoreCase: false,
						want:       "\"while\"",
					},
					&litMatcher{
						pos:        position{line: 345, col: 23, offset: 17298},
						val:        "if",
						ignoreCase: false,
						want:       "\"if\"",
					},
					&litMatcher{
						pos:        position{line: 345, col: 30, offset: 17305},
						val:        "else",
						ignoreCase: false,
						want:       "\"else\"",
					},
					&litMatcher{
						pos:        position{line: 345, col: 39, offset: 17314},
						val:        "continue",
						ignoreCase: false,
						want:       "\"continue\"",
					},
					&litMatcher{
						pos:        position{line: 345, col: 52, offset: 17327},
						val:        "break",
						ignoreCase: false,
						want:       "\"break\"",
					},
					&litMatcher{
						pos:        position{line: 345, col: 62, offset: 17337},
						val:        "return",
						ignoreCase: false,
						want:       "\"return\"",
					},
					&litMatcher{
						pos:        position{line: 345, col: 73, offset: 17348},
						val:        "func",
						ignoreCase: false,
						want:       "\"func\"",
					},
				},
			},
		},
		{
			name: "keywords_test",
			pos:  position{line: 346, col: 1, offset: 17355},
			expr: &notExpr{
				pos: position{line: 346, col: 18, offset: 17372},
				expr: &seqExpr{
					pos: position{line: 346, col: 20, offset: 17374},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 346, col: 20, offset: 17374},
							name: "keywords",
						},
						&notExpr{
							pos: position{line: 346, col: 29, offset: 17383},
							expr: &ruleRefExpr{
								pos:  position{line: 346, col: 30, offset: 17384},
								name: "xidContinue",
							},
						},
					},
				},
			},
		},
		{
			name: "identifier",
			pos:  position{line: 348, col: 1, offset: 17398},
			expr: &actionExpr{
				pos: position{line: 348, col: 15, offset: 17412},
				run: (*parser).callonidentifier1,
				expr: &seqExpr{
					pos: position{line: 348, col: 15, offset: 17412},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 348, col: 15, offset: 17412},
							name: "keywords_test",
						},
						&ruleRefExpr{
							pos:  position{line: 348, col: 29, offset: 17426},
							name: "xidStart",
						},
						&zeroOrMoreExpr{
							pos: position{line: 348, col: 38, offset: 17435},
							expr: &choiceExpr{
								pos: position{line: 348, col: 39, offset: 17436},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 348, col: 39, offset: 17436},
										name: "xidContinue",
									},
									&litMatcher{
										pos:        position{line: 348, col: 53, offset: 17450},
										val:        ":",
										ignoreCase: false,
										want:       "\":\"",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "identifierWithoutColon",
			pos:  position{line: 353, col: 1, offset: 17588},
			expr: &actionExpr{
				pos: position{line: 353, col: 27, offset: 17614},
				run: (*parser).callonidentifierWithoutColon1,
				expr: &seqExpr{
					pos: position{line: 353, col: 27, offset: 17614},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 353, col: 27, offset: 17614},
							name: "keywords_test",
						},
						&ruleRefExpr{
							pos:  position{line: 353, col: 41, offset: 17628},
							name: "xidStart",
						},
						&zeroOrMoreExpr{
							pos: position{line: 353, col: 50, offset: 17637},
							expr: &ruleRefExpr{
								pos:  position{line: 353, col: 50, offset: 17637},
								name: "xidContinue",
							},
						},
					},
				},
			},
		},
		{
			name: "xidStart",
			pos:  position{line: 358, col: 1, offset: 17703},
			expr: &charClassMatcher{
				pos:        position{line: 358, col: 13, offset: 17715},
				val:        "[_\\p{L}\\p{Other_ID_Start}]",
				chars:      []rune{'_'},
				classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Other_ID_Start")},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "xidContinue",
			pos:  position{line: 361, col: 1, offset: 17814},
			expr: &charClassMatcher{
				pos:        position{line: 361, col: 16, offset: 17829},
				val:        "[\\p{L}\\p{Other_ID_Start}\\p{Nl}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\p{Other_ID_Continue}]",
				classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Other_ID_Start"), rangeTable("Nl"), rangeTable("Mn"), rangeTable("Mc"), rangeTable("Nd"), rangeTable("Pc"), rangeTable("Other_ID_Continue")},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "sub",
			pos:  position{line: 364, col: 1, offset: 17917},
			expr: &seqExpr{
				pos: position{line: 364, col: 8, offset: 17924},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 364, col: 8, offset: 17924},
						name: "parenOpen",
					},
					&ruleRefExpr{
						pos:  position{line: 364, col: 18, offset: 17934},
						name: "exprRoot",
					},
					&ruleRefExpr{
						pos:  position{line: 364, col: 27, offset: 17943},
						name: "parenClose",
					},
				},
			},
		},
		{
			name: "parenOpen",
			pos:  position{line: 365, col: 1, offset: 17954},
			expr: &seqExpr{
				pos: position{line: 365, col: 14, offset: 17967},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 365, col: 14, offset: 17967},
						val:        "(",
						ignoreCase: false,
						want:       "\"(\"",
					},
					&ruleRefExpr{
						pos:  position{line: 365, col: 18, offset: 17971},
						name: "sp",
					},
				},
			},
		},
		{
			name: "parenClose",
			pos:  position{line: 366, col: 1, offset: 17974},
			expr: &seqExpr{
				pos: position{line: 366, col: 15, offset: 17988},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 366, col: 15, offset: 17988},
						val:        ")",
						ignoreCase: false,
						want:       "\")\"",
					},
					&ruleRefExpr{
						pos:  position{line: 366, col: 19, offset: 17992},
						name: "sp",
					},
				},
			},
		},
		{
			name: "add",
			pos:  position{line: 369, col: 1, offset: 18035},
			expr: &seqExpr{
				pos: position{line: 369, col: 8, offset: 18042},
				exprs: []any{
					&choiceExpr{
						pos: position{line: 369, col: 9, offset: 18043},
						alternatives: []any{
							&litMatcher{
								pos:        position{line: 369, col: 9, offset: 18043},
								val:        "+",
								ignoreCase: false,
								want:       "\"+\"",
							},
							&litMatcher{
								pos:        position{line: 369, col: 13, offset: 18047},
								val:        "＋",
								ignoreCase: false,
								want:       "\"＋\"",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 369, col: 18, offset: 18054},
						name: "sp",
					},
				},
			},
		},
		{
			name: "minus",
			pos:  position{line: 370, col: 1, offset: 18057},
			expr: &seqExpr{
				pos: position{line: 370, col: 10, offset: 18066},
				exprs: []any{
					&choiceExpr{
						pos: position{line: 370, col: 11, offset: 18067},
						alternatives: []any{
							&litMatcher{
								pos:        position{line: 370, col: 11, offset: 18067},
								val:        "-",
								ignoreCase: false,
								want:       "\"-\"",
							},
							&litMatcher{
								pos:        position{line: 370, col: 17, offset: 18073},
								val:        "－",
								ignoreCase: false,
								want:       "\"－\"",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 370, col: 22, offset: 18080},
						name: "sp",
					},
				},
			},
		},
		{
			name: "multiply",
			pos:  position{line: 371, col: 1, offset: 18083},
			expr: &seqExpr{
				pos: position{line: 371, col: 13, offset: 18095},
				exprs: []any{
					&choiceExpr{
						pos: position{line: 371, col: 14, offset: 18096},
						alternatives: []any{
							&litMatcher{
								pos:        position{line: 371, col: 14, offset: 18096},
								val:        "*",
								ignoreCase: false,
								want:       "\"*\"",
							},
							&litMatcher{
								pos:        position{line: 371, col: 20, offset: 18102},
								val:        "＊",
								ignoreCase: false,
								want:       "\"＊\"",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 371, col: 25, offset: 18109},
						name: "sp",
					},
				},
			},
		},
		{
			name: "divide",
			pos:  position{line: 372, col: 1, offset: 18112},
			expr: &seqExpr{
				pos: position{line: 372, col: 11, offset: 18122},
				exprs: []any{
					&choiceExpr{
						pos: position{line: 372, col: 12, offset: 18123},
						alternatives: []any{
							&litMatcher{
								pos:        position{line: 372, col: 12, offset: 18123},
								val:        "/",
								ignoreCase: false,
								want:       "\"/\"",
							},
							&litMatcher{
								pos:        position{line: 372, col: 18, offset: 18129},
								val:        "／",
								ignoreCase: false,
								want:       "\"／\"",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 372, col: 23, offset: 18136},
						name: "sp",
					},
				},
			},
		},
		{
			name: "modulus",
			pos:  position{line: 373, col: 1, offset: 18139},
			expr: &seqExpr{
				pos: position{line: 373, col: 12, offset: 18150},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 373, col: 12, offset: 18150},
						val:        "%",
						ignoreCase: false,
						want:       "\"%\"",
					},
					&ruleRefExpr{
						pos:  position{line: 373, col: 16, offset: 18154},
						name: "sp",
					},
				},
			},
		},
		{
			name: "exponentiation",
			pos:  position{line: 374, col: 1, offset: 18157},
			expr: &choiceExpr{
				pos: position{line: 374, col: 19, offset: 18175},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 374, col: 19, offset: 18175},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 374, col: 19, offset: 18175},
								val:        "^",
								ignoreCase: false,
								want:       "\"^\"",
							},
							&ruleRefExpr{
								pos:  position{line: 374, col: 23, offset: 18179},
								name: "sp",
							},
						},
					},
					&seqExpr{
						pos: position{line: 374, col: 28, offset: 18184},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 374, col: 28, offset: 18184},
								val:        "**",
								ignoreCase: false,
								want:       "\"**\"",
							},
							&ruleRefExpr{
								pos:  position{line: 374, col: 33, offset: 18189},
								name: "sp",
							},
						},
					},
				},
			},
		},
		{
			name: "nullCoalescing",
			pos:  position{line: 375, col: 1, offset: 18192},
			expr: &seqExpr{
				pos: position{line: 375, col: 19, offset: 18210},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 375, col: 19, offset: 18210},
						val:        "??",
						ignoreCase: false,
						want:       "\"??\"",
					},
					&ruleRefExpr{
						pos:  position{line: 375, col: 24, offset: 18215},
						name: "sp",
					},
				},
			},
		},
		{
			name: "bitwiseOr",
			pos:  position{line: 377, col: 1, offset: 18234},
			expr: &seqExpr{
				pos: position{line: 377, col: 14, offset: 18247},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 377, col: 14, offset: 18247},
						val:        "|",
						ignoreCase: false,
						want:       "\"|\"",
					},
					&ruleRefExpr{
						pos:  position{line: 377, col: 18, offset: 18251},
						name: "sp",
					},
				},
			},
		},
		{
			name: "bitwiseAnd",
			pos:  position{line: 378, col: 1, offset: 18254},
			expr: &seqExpr{
				pos: position{line: 378, col: 15, offset: 18268},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 378, col: 15, offset: 18268},
						val:        "&",
						ignoreCase: false,
						want:       "\"&\"",
					},
					&ruleRefExpr{
						pos:  position{line: 378, col: 19, offset: 18272},
						name: "sp",
					},
				},
			},
		},
		{
			name: "logicOr",
			pos:  position{line: 381, col: 1, offset: 18292},
			expr: &seqExpr{
				pos: position{line: 381, col: 12, offset: 18303},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 381, col: 12, offset: 18303},
						val:        "||",
						ignoreCase: false,
						want:       "\"||\"",
					},
					&ruleRefExpr{
						pos:  position{line: 381, col: 17, offset: 18308},
						name: "sp",
					},
				},
			},
		},
		{
			name: "logicAnd",
			pos:  position{line: 382, col: 1, offset: 18311},
			expr: &seqExpr{
				pos: position{line: 382, col: 13, offset: 18323},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 382, col: 13, offset: 18323},
						val:        "&&",
						ignoreCase: false,
						want:       "\"&&\"",
					},
					&ruleRefExpr{
						pos:  position{line: 382, col: 18, offset: 18328},
						name: "sp",
					},
				},
			},
		},
		{
			name: "lt",
			pos:  position{line: 386, col: 1, offset: 18471},
			expr: &seqExpr{
				pos: position{line: 386, col: 7, offset: 18477},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 386, col: 7, offset: 18477},
						val:        "<",
						ignoreCase: false,
						want:       "\"<\"",
					},
					&ruleRefExpr{
						pos:  position{line: 386, col: 11, offset: 18481},
						name: "sp",
					},
				},
			},
		},
		{
			name: "gt",
			pos:  position{line: 387, col: 1, offset: 18484},
			expr: &seqExpr{
				pos: position{line: 387, col: 7, offset: 18490},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 387, col: 7, offset: 18490},
						val:        ">",
						ignoreCase: false,
						want:       "\">\"",
					},
					&ruleRefExpr{
						pos:  position{line: 387, col: 11, offset: 18494},
						name: "sp",
					},
				},
			},
		},
		{
			name: "le",
			pos:  position{line: 388, col: 1, offset: 18497},
			expr: &seqExpr{
				pos: position{line: 388, col: 7, offset: 18503},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 388, col: 7, offset: 18503},
						val:        "<=",
						ignoreCase: false,
						want:       "\"<=\"",
					},
					&ruleRefExpr{
						pos:  position{line: 388, col: 12, offset: 18508},
						name: "sp",
					},
				},
			},
		},
		{
			name: "ge",
			pos:  position{line: 389, col: 1, offset: 18511},
			expr: &seqExpr{
				pos: position{line: 389, col: 7, offset: 18517},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 389, col: 7, offset: 18517},
						val:        ">=",
						ignoreCase: false,
						want:       "\">=\"",
					},
					&ruleRefExpr{
						pos:  position{line: 389, col: 12, offset: 18522},
						name: "sp",
					},
				},
			},
		},
		{
			name: "eq",
			pos:  position{line: 390, col: 1, offset: 18525},
			expr: &seqExpr{
				pos: position{line: 390, col: 7, offset: 18531},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 390, col: 7, offset: 18531},
						val:        "==",
						ignoreCase: false,
						want:       "\"==\"",
					},
					&ruleRefExpr{
						pos:  position{line: 390, col: 12, offset: 18536},
						name: "sp",
					},
				},
			},
		},
		{
			name: "ne",
			pos:  position{line: 391, col: 1, offset: 18539},
			expr: &seqExpr{
				pos: position{line: 391, col: 7, offset: 18545},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 391, col: 7, offset: 18545},
						val:        "!=",
						ignoreCase: false,
						want:       "\"!=\"",
					},
					&ruleRefExpr{
						pos:  position{line: 391, col: 12, offset: 18550},
						name: "sp",
					},
				},
			},
		},
		{
			name:        "sp",
			displayName: "\"whitespace\"",
			pos:         position{line: 394, col: 1, offset: 18564},
			expr: &zeroOrMoreExpr{
				pos: position{line: 394, col: 20, offset: 18583},
				expr: &charClassMatcher{
					pos:        position{line: 394, col: 20, offset: 18583},
					val:        "[ \\n\\t\\r]",
					chars:      []rune{' ', '\n', '\t', '\r'},
					ignoreCase: false,
					inverted:   false,
				},
			},
		},
		{
			name:        "sp1",
			displayName: "\"whitespace\"",
			pos:         position{line: 395, col: 1, offset: 18594},
			expr: &choiceExpr{
				pos: position{line: 395, col: 21, offset: 18614},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 395, col: 21, offset: 18614},
						exprs: []any{
							&charClassMatcher{
								pos:        position{line: 395, col: 21, offset: 18614},
								val:        "[ \\n\\t\\r]",
								chars:      []rune{' ', '\n', '\t', '\r'},
								ignoreCase: false,
								inverted:   false,
							},
							&ruleRefExpr{
								pos:  position{line: 395, col: 31, offset: 18624},
								name: "sp",
							},
						},
					},
					&notExpr{
						pos: position{line: 395, col: 36, offset: 18629},
						expr: &anyMatcher{
							line: 395, col: 37, offset: 18630,
						},
					},
				},
			},
		},
		{
			name: "sp1x",
			pos:  position{line: 396, col: 1, offset: 18632},
			expr: &seqExpr{
				pos: position{line: 396, col: 9, offset: 18640},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 396, col: 9, offset: 18640},
						name: "sp1",
					},
					&ruleRefExpr{
						pos:  position{line: 396, col: 13, offset: 18644},
						name: "sp",
					},
				},
			},
		},
		{
			name: "spNoCR",
			pos:  position{line: 397, col: 1, offset: 18647},
			expr: &zeroOrMoreExpr{
				pos: position{line: 397, col: 11, offset: 18657},
				expr: &charClassMatcher{
					pos:        position{line: 397, col: 11, offset: 18657},
					val:        "[ \\t]",
					chars:      []rune{' ', '\t'},
					ignoreCase: false,
					inverted:   false,
				},
			},
		},
		{
			name: "comment",
			pos:  position{line: 398, col: 1, offset: 18664},
			expr: &seqExpr{
				pos: position{line: 398, col: 12, offset: 18675},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 398, col: 12, offset: 18675},
						name: "spNoCR",
					},
					&litMatcher{
						pos:        position{line: 398, col: 19, offset: 18682},
						val:        "//",
						ignoreCase: false,
						want:       "\"//\"",
					},
					&ruleRefExpr{
						pos:  position{line: 398, col: 24, offset: 18687},
						name: "commentLineRest",
					},
				},
			},
		},
		{
			name: "commentLineRest",
			pos:  position{line: 399, col: 1, offset: 18703},
			expr: &seqExpr{
				pos: position{line: 399, col: 20, offset: 18722},
				exprs: []any{
					&zeroOrMoreExpr{
						pos: position{line: 399, col: 20, offset: 18722},
						expr: &seqExpr{
							pos: position{line: 399, col: 21, offset: 18723},
							exprs: []any{
								&notExpr{
									pos: position{line: 399, col: 21, offset: 18723},
									expr: &charClassMatcher{
										pos:        position{line: 399, col: 22, offset: 18724},
										val:        "[\\r\\n]",
										chars:      []rune{'\r', '\n'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&anyMatcher{
									line: 399, col: 29, offset: 18731,
								},
							},
						},
					},
					&choiceExpr{
						pos: position{line: 399, col: 34, offset: 18736},
						alternatives: []any{
							&charClassMatcher{
								pos:        position{line: 399, col: 34, offset: 18736},
								val:        "[\\r\\n]",
								chars:      []rune{'\r', '\n'},
								ignoreCase: false,
								inverted:   false,
							},
							&notExpr{
								pos: position{line: 399, col: 43, offset: 18745},
								expr: &anyMatcher{
									line: 399, col: 44, offset: 18746,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "commentLineRest2",
			pos:  position{line: 400, col: 1, offset: 18749},
			expr: &seqExpr{
				pos: position{line: 400, col: 21, offset: 18769},
				exprs: []any{
					&zeroOrMoreExpr{
						pos: position{line: 400, col: 21, offset: 18769},
						expr: &seqExpr{
							pos: position{line: 400, col: 22, offset: 18770},
							exprs: []any{
								&notExpr{
									pos: position{line: 400, col: 22, offset: 18770},
									expr: &charClassMatcher{
										pos:        position{line: 400, col: 23, offset: 18771},
										val:        "[\\r\\n]",
										chars:      []rune{'\r', '\n'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&anyMatcher{
									line: 400, col: 30, offset: 18778,
								},
							},
						},
					},
					&charClassMatcher{
						pos:        position{line: 400, col: 34, offset: 18782},
						val:        "[\\r\\n]",
						chars:      []rune{'\r', '\n'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "st_expr",
			pos:  position{line: 420, col: 1, offset: 19293},
			expr: &choiceExpr{
				pos: position{line: 420, col: 12, offset: 19304},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 420, col: 12, offset: 19304},
						name: "st_modify_multi_1",
					},
					&ruleRefExpr{
						pos:  position{line: 421, col: 13, offset: 19334},
						name: "st_assign_multi",
					},
					&ruleRefExpr{
						pos:  position{line: 422, col: 13, offset: 19362},
						name: "st_modify_multi_2",
					},
				},
			},
		},
		{
			name: "e0",
			pos:  position{line: 426, col: 1, offset: 19422},
			expr: &ruleRefExpr{
				pos:  position{line: 426, col: 7, offset: 19428},
				name: "stmtRoot",
			},
		},
		{
			name: "est",
			pos:  position{line: 427, col: 1, offset: 19437},
			expr: &choiceExpr{
				pos: position{line: 427, col: 8, offset: 19444},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 427, col: 10, offset: 19446},
						exprs: []any{
							&andExpr{
								pos: position{line: 427, col: 10, offset: 19446},
								expr: &litMatcher{
									pos:        position{line: 427, col: 11, offset: 19447},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 427, col: 15, offset: 19451},
								name: "e0",
							},
						},
					},
					&seqExpr{
						pos: position{line: 428, col: 8, offset: 19463},
						exprs: []any{
							&actionExpr{
								pos: position{line: 428, col: 8, offset: 19463},
								run: (*parser).callonest7,
								expr: &andExpr{
									pos: position{line: 428, col: 8, offset: 19463},
									expr: &ruleRefExpr{
										pos:  position{line: 428, col: 9, offset: 19464},
										name: "e0",
									},
								},
							},
							&actionExpr{
								pos: position{line: 428, col: 104, offset: 19559},
								run: (*parser).callonest10,
								expr: &ruleRefExpr{
									pos:  position{line: 428, col: 104, offset: 19559},
									name: "e0",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "st_assign_multi",
			pos:  position{line: 430, col: 1, offset: 19585},
			expr: &oneOrMoreExpr{
				pos: position{line: 430, col: 20, offset: 19604},
				expr: &seqExpr{
					pos: position{line: 430, col: 21, offset: 19605},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 430, col: 21, offset: 19605},
							name: "st_assign",
						},
						&ruleRefExpr{
							pos:  position{line: 430, col: 31, offset: 19615},
							name: "sp",
						},
						&zeroOrOneExpr{
							pos: position{line: 430, col: 34, offset: 19618},
							expr: &litMatcher{
								pos:        position{line: 430, col: 34, offset: 19618},
								val:        ",",
								ignoreCase: false,
								want:       "\",\"",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 430, col: 39, offset: 19623},
							name: "sp",
						},
					},
				},
			},
		},
		{
			name: "st_star",
			pos:  position{line: 432, col: 1, offset: 19629},
			expr: &seqExpr{
				pos: position{line: 432, col: 12, offset: 19640},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 432, col: 12, offset: 19640},
						val:        "*",
						ignoreCase: false,
						want:       "\"*\"",
					},
					&ruleRefExpr{
						pos:  position{line: 432, col: 16, offset: 19644},
						name: "sp",
					},
					&choiceExpr{
						pos: position{line: 432, col: 20, offset: 19648},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 432, col: 20, offset: 19648},
								name: "float",
							},
							&ruleRefExpr{
								pos:  position{line: 432, col: 28, offset: 19656},
								name: "number",
							},
							&ruleRefExpr{
								pos:  position{line: 432, col: 37, offset: 19665},
								name: "sub",
							},
						},
					},
				},
			},
		},
		{
			name: "st_assign",
			pos:  position{line: 433, col: 1, offset: 19670},
			expr: &choiceExpr{
				pos: position{line: 433, col: 14, offset: 19683},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 433, col: 14, offset: 19683},
						run: (*parser).callonst_assign2,
						expr: &seqExpr{
							pos: position{line: 433, col: 14, offset: 19683},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 433, col: 14, offset: 19683},
									name: "st_name2",
								},
								&ruleRefExpr{
									pos:  position{line: 433, col: 23, offset: 19692},
									name: "sp",
								},
								&choiceExpr{
									pos: position{line: 433, col: 27, offset: 19696},
									alternatives: []any{
										&litMatcher{
											pos:        position{line: 433, col: 27, offset: 19696},
											val:        ":",
											ignoreCase: false,
											want:       "\":\"",
										},
										&litMatcher{
											pos:        position{line: 433, col: 33, offset: 19702},
											val:        "=",
											ignoreCase: false,
											want:       "\"=\"",
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 433, col: 38, offset: 19707},
									name: "sp",
								},
								&ruleRefExpr{
									pos:  position{line: 433, col: 41, offset: 19710},
									name: "est",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 434, col: 14, offset: 19788},
						run: (*parser).callonst_assign11,
						expr: &seqExpr{
							pos: position{line: 434, col: 14, offset: 19788},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 434, col: 14, offset: 19788},
									name: "st_name1",
								},
								&ruleRefExpr{
									pos:  position{line: 434, col: 23, offset: 19797},
									name: "est",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 435, col: 14, offset: 19856},
						run: (*parser).callonst_assign15,
						expr: &seqExpr{
							pos: position{line: 435, col: 14, offset: 19856},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 435, col: 14, offset: 19856},
									name: "st_name2r",
								},
								&ruleRefExpr{
									pos:  position{line: 435, col: 24, offset: 19866},
									name: "sp",
								},
								&ruleRefExpr{
									pos:  position{line: 435, col: 27, offset: 19869},
									name: "st_star",
								},
								&ruleRefExpr{
									pos:  position{line: 435, col: 35, offset: 19877},
									name: "sp",
								},
								&choiceExpr{
									pos: position{line: 435, col: 39, offset: 19881},
									alternatives: []any{
										&litMatcher{
											pos:        position{line: 435, col: 39, offset: 19881},
											val:        ":",
											ignoreCase: false,
											want:       "\":\"",
										},
										&litMatcher{
											pos:        position{line: 435, col: 45, offset: 19887},
											val:        "=",
											ignoreCase: false,
											want:       "\"=\"",
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 435, col: 50, offset: 19892},
									name: "sp",
								},
								&ruleRefExpr{
									pos:  position{line: 435, col: 53, offset: 19895},
									name: "est",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 436, col: 14, offset: 19957},
						run: (*parser).callonst_assign26,
						expr: &seqExpr{
							pos: position{line: 436, col: 14, offset: 19957},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 436, col: 14, offset: 19957},
									name: "st_name2r",
								},
								&ruleRefExpr{
									pos:  position{line: 436, col: 24, offset: 19967},
									name: "sp",
								},
								&litMatcher{
									pos:        position{line: 436, col: 27, offset: 19970},
									val:        "*",
									ignoreCase: false,
									want:       "\"*\"",
								},
								&ruleRefExpr{
									pos:  position{line: 436, col: 31, offset: 19974},
									name: "sp",
								},
								&choiceExpr{
									pos: position{line: 436, col: 35, offset: 19978},
									alternatives: []any{
										&litMatcher{
											pos:        position{line: 436, col: 35, offset: 19978},
											val:        ":",
											ignoreCase: false,
											want:       "\":\"",
										},
										&litMatcher{
											pos:        position{line: 436, col: 41, offset: 19984},
											val:        "=",
											ignoreCase: false,
											want:       "\"=\"",
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 436, col: 46, offset: 19989},
									name: "sp",
								},
								&ruleRefExpr{
									pos:  position{line: 436, col: 49, offset: 19992},
									name: "est",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 437, col: 14, offset: 20050},
						run: (*parser).callonst_assign37,
						expr: &seqExpr{
							pos: position{line: 437, col: 14, offset: 20050},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 437, col: 14, offset: 20050},
									name: "st_name2r",
								},
								&ruleRefExpr{
									pos:  position{line: 437, col: 24, offset: 20060},
									name: "sp",
								},
								&choiceExpr{
									pos: position{line: 437, col: 28, offset: 20064},
									alternatives: []any{
										&litMatcher{
											pos:        position{line: 437, col: 28, offset: 20064},
											val:        ":",
											ignoreCase: false,
											want:       "\":\"",
										},
										&litMatcher{
											pos:        position{line: 437, col: 34, offset: 20070},
											val:        "=",
											ignoreCase: false,
											want:       "\"=\"",
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 437, col: 39, offset: 20075},
									name: "sp",
								},
								&ruleRefExpr{
									pos:  position{line: 437, col: 42, offset: 20078},
									name: "est",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 438, col: 14, offset: 20133},
						run: (*parser).callonst_assign46,
						expr: &seqExpr{
							pos: position{line: 438, col: 14, offset: 20133},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 438, col: 14, offset: 20133},
									name: "st_name1r",
								},
								&ruleRefExpr{
									pos:  position{line: 438, col: 24, offset: 20143},
									name: "est",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 439, col: 14, offset: 20195},
						exprs: []any{
							&actionExpr{
								pos: position{line: 439, col: 14, offset: 20195},
								run: (*parser).callonst_assign51,
								expr: &seqExpr{
									pos: position{line: 439, col: 14, offset: 20195},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 439, col: 14, offset: 20195},
											val:        "&",
											ignoreCase: false,
											want:       "\"&\"",
										},
										&ruleRefExpr{
											pos:  position{line: 439, col: 18, offset: 20199},
											name: "st_name2",
										},
										&ruleRefExpr{
											pos:  position{line: 439, col: 27, offset: 20208},
											name: "sp",
										},
										&choiceExpr{
											pos: position{line: 439, col: 31, offset: 20212},
											alternatives: []any{
												&litMatcher{
													pos:        position{line: 439, col: 31, offset: 20212},
													val:        ":",
													ignoreCase: false,
													want:       "\":\"",
												},
												&litMatcher{
													pos:        position{line: 439, col: 37, offset: 20218},
													val:        "=",
													ignoreCase: false,
													want:       "\"=\"",
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 439, col: 42, offset: 20223},
											name: "sp",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 439, col: 67, offset: 20248},
								run: (*parser).callonst_assign60,
								expr: &labeledExpr{
									pos:   position{line: 439, col: 67, offset: 20248},
									label: "text",
									expr: &ruleRefExpr{
										pos:  position{line: 439, col: 74, offset: 20255},
										name: "est",
									},
									textCapture: true,
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 440, col: 14, offset: 20379},
						exprs: []any{
							&actionExpr{
								pos: position{line: 440, col: 14, offset: 20379},
								run: (*parser).callonst_assign64,
								expr: &seqExpr{
									pos: position{line: 440, col: 14, offset: 20379},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 440, col: 14, offset: 20379},
											val:        "&",
											ignoreCase: false,
											want:       "\"&\"",
										},
										&ruleRefExpr{
											pos:  position{line: 440, col: 18, offset: 20383},
											name: "st_name2r",
										},
										&ruleRefExpr{
											pos:  position{line: 440, col: 28, offset: 20393},
											name: "sp",
										},
										&choiceExpr{
											pos: position{line: 440, col: 32, offset: 20397},
											alternatives: []any{
												&litMatcher{
													pos:        position{line: 440, col: 32, offset: 20397},
													val:        ":",
													ignoreCase: false,
													want:       "\":\"",
												},
												&litMatcher{
													pos:        position{line: 440, col: 38, offset: 20403},
													val:        "=",
													ignoreCase: false,
													want:       "\"=\"",
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 440, col: 43, offset: 20408},
											name: "sp",
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 440, col: 68, offset: 20433},
								run: (*parser).callonst_assign73,
								expr: &labeledExpr{
									pos:   position{line: 440, col: 68, offset: 20433},
									label: "text",
									expr: &ruleRefExpr{
										pos:  position{line: 440, col: 75, offset: 20440},
										name: "est",
									},
									textCapture: true,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "st_modify_multi_1",
			pos:  position{line: 445, col: 1, offset: 20598},
			expr: &seqExpr{
				pos: position{line: 445, col: 22, offset: 20619},
				exprs: []any{
					&seqExpr{
						pos: position{line: 445, col: 23, offset: 20620},
						exprs: []any{
							&choiceExpr{
								pos: position{line: 445, col: 24, offset: 20621},
								alternatives: []any{
									&seqExpr{
										pos: position{line: 445, col: 24, offset: 20621},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 445, col: 24, offset: 20621},
												name: "st_name2",
											},
											&ruleRefExpr{
												pos:  position{line: 445, col: 33, offset: 20630},
												name: "st_modify_rest1",
											},
										},
									},
									&seqExpr{
										pos: position{line: 445, col: 51, offset: 20648},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 445, col: 51, offset: 20648},
												name: "st_name2r",
											},
											&ruleRefExpr{
												pos:  position{line: 445, col: 61, offset: 20658},
												name: "st_modify_rest1",
											},
										},
									},
									&seqExpr{
										pos: position{line: 445, col: 79, offset: 20676},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 445, col: 79, offset: 20676},
												name: "st_name1",
											},
											&ruleRefExpr{
												pos:  position{line: 445, col: 88, offset: 20685},
												name: "st_modify_rest",
											},
										},
									},
									&seqExpr{
										pos: position{line: 445, col: 105, offset: 20702},
										exprs: []any{
											&ruleRefExpr{
												pos:  position{line: 445, col: 105, offset: 20702},
												name: "st_name1r",
											},
											&ruleRefExpr{
												pos:  position{line: 445, col: 115, offset: 20712},
												name: "st_modify_rest",
											},
										},
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 445, col: 131, offset: 20728},
								name: "sp",
							},
							&zeroOrOneExpr{
								pos: position{line: 445, col: 134, offset: 20731},
								expr: &litMatcher{
									pos:        position{line: 445, col: 134, offset: 20731},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 445, col: 139, offset: 20736},
								name: "sp",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 445, col: 144, offset: 20741},
						name: "st_modify_multi_rest",
					},
				},
			},
		},
		{
			name: "st_modify_rest1",
			pos:  position{line: 447, col: 1, offset: 20763},
			expr: &seqExpr{
				pos: position{line: 447, col: 20, offset: 20782},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 447, col: 20, offset: 20782},
						name: "sp",
					},
					&choiceExpr{
						pos: position{line: 448, col: 6, offset: 20792},
						alternatives: []any{
							&actionExpr{
								pos: position{line: 448, col: 6, offset: 20792},
								run: (*parser).callonst_modify_rest14,
								expr: &seqExpr{
									pos: position{line: 448, col: 6, offset: 20792},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 448, col: 6, offset: 20792},
											val:        "+=",
											ignoreCase: false,
											want:       "\"+=\"",
										},
										&ruleRefExpr{
											pos:  position{line: 448, col: 11, offset: 20797},
											name: "sp",
										},
										&labeledExpr{
											pos:   position{line: 448, col: 14, offset: 20800},
											label: "text",
											expr: &ruleRefExpr{
												pos:  position{line: 448, col: 21, offset: 20807},
												name: "e0",
											},
											textCapture: true,
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 449, col: 6, offset: 20860},
								run: (*parser).callonst_modify_rest110,
								expr: &seqExpr{
									pos: position{line: 449, col: 6, offset: 20860},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 449, col: 6, offset: 20860},
											val:        "-=",
											ignoreCase: false,
											want:       "\"-=\"",
										},
										&ruleRefExpr{
											pos:  position{line: 449, col: 11, offset: 20865},
											name: "sp",
										},
										&labeledExpr{
											pos:   position{line: 449, col: 14, offset: 20868},
											label: "text",
											expr: &ruleRefExpr{
												pos:  position{line: 449, col: 21, offset: 20875},
												name: "e0",
											},
											textCapture: true,
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "st_modify_multi_2",
			pos:  position{line: 455, col: 1, offset: 20990},
			expr: &seqExpr{
				pos: position{line: 455, col: 22, offset: 21011},
				exprs: []any{
					&seqExpr{
						pos: position{line: 455, col: 23, offset: 21012},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 455, col: 23, offset: 21012},
								name: "st_modify2",
							},
							&ruleRefExpr{
								pos:  position{line: 455, col: 34, offset: 21023},
								name: "sp",
							},
							&zeroOrOneExpr{
								pos: position{line: 455, col: 37, offset: 21026},
								expr: &litMatcher{
									pos:        position{line: 455, col: 37, offset: 21026},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 455, col: 42, offset: 21031},
								name: "sp",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 455, col: 46, offset: 21035},
						name: "st_modify_multi_rest",
					},
				},
			},
		},
		{
			name: "st_modify_multi_rest",
			pos:  position{line: 457, col: 1, offset: 21057},
			expr: &zeroOrMoreExpr{
				pos: position{line: 457, col: 25, offset: 21081},
				expr: &seqExpr{
					pos: position{line: 457, col: 26, offset: 21082},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 457, col: 26, offset: 21082},
							name: "st_modify2",
						},
						&ruleRefExpr{
							pos:  position{line: 457, col: 37, offset: 21093},
							name: "sp",
						},
						&zeroOrOneExpr{
							pos: position{line: 457, col: 40, offset: 21096},
							expr: &litMatcher{
								pos:        position{line: 457, col: 40, offset: 21096},
								val:        ",",
								ignoreCase: false,
								want:       "\",\"",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 457, col: 45, offset: 21101},
							name: "sp",
						},
					},
				},
			},
		},
		{
			name: "st_modify2",
			pos:  position{line: 458, col: 1, offset: 21106},
			expr: &choiceExpr{
				pos: position{line: 458, col: 15, offset: 21120},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 458, col: 15, offset: 21120},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 458, col: 15, offset: 21120},
								name: "st_name2",
							},
							&ruleRefExpr{
								pos:  position{line: 458, col: 24, offset: 21129},
								name: "st_modify_rest",
							},
						},
					},
					&seqExpr{
						pos: position{line: 459, col: 15, offset: 21158},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 459, col: 15, offset: 21158},
								name: "st_name2r",
							},
							&ruleRefExpr{
								pos:  position{line: 459, col: 25, offset: 21168},
								name: "st_modify_rest",
							},
						},
					},
				},
			},
		},
		{
			name: "st_modify_rest",
			pos:  position{line: 461, col: 1, offset: 21184},
			expr: &seqExpr{
				pos: position{line: 461, col: 19, offset: 21202},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 461, col: 19, offset: 21202},
						name: "sp",
					},
					&choiceExpr{
						pos: position{line: 462, col: 6, offset: 21212},
						alternatives: []any{
							&actionExpr{
								pos: position{line: 462, col: 6, offset: 21212},
								run: (*parser).callonst_modify_rest4,
								expr: &seqExpr{
									pos: position{line: 462, col: 6, offset: 21212},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 462, col: 6, offset: 21212},
											val:        "+",
											ignoreCase: false,
											want:       "\"+\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 462, col: 10, offset: 21216},
											expr: &litMatcher{
												pos:        position{line: 462, col: 10, offset: 21216},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 462, col: 15, offset: 21221},
											name: "sp",
										},
										&labeledExpr{
											pos:   position{line: 462, col: 18, offset: 21224},
											label: "text",
											expr: &ruleRefExpr{
												pos:  position{line: 462, col: 25, offset: 21231},
												name: "e0",
											},
											textCapture: true,
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 463, col: 6, offset: 21284},
								run: (*parser).callonst_modify_rest12,
								expr: &seqExpr{
									pos: position{line: 463, col: 6, offset: 21284},
									exprs: []any{
										&andExpr{
											pos: position{line: 463, col: 6, offset: 21284},
											expr: &litMatcher{
												pos:        position{line: 463, col: 9, offset: 21287},
												val:        "-",
												ignoreCase: false,
												want:       "\"-\"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 463, col: 15, offset: 21293},
											name: "sp",
										},
										&labeledExpr{
											pos:   position{line: 463, col: 18, offset: 21296},
											label: "text",
											expr: &ruleRefExpr{
												pos:  position{line: 463, col: 25, offset: 21303},
												name: "e0",
											},
											textCapture: true,
										},
									},
								},
							},
							&actionExpr{
								pos: position{line: 464, col: 6, offset: 21356},
								run: (*parser).callonst_modify_rest19,
								expr: &seqExpr{
									pos: position{line: 464, col: 6, offset: 21356},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 464, col: 6, offset: 21356},
											val:        "-",
											ignoreCase: false,
											want:       "\"-\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 464, col: 10, offset: 21360},
											expr: &litMatcher{
												pos:        position{line: 464, col: 10, offset: 21360},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 464, col: 15, offset: 21365},
											name: "sp",
										},
										&labeledExpr{
											pos:   position{line: 464, col: 18, offset: 21368},
											label: "text",
											expr: &ruleRefExpr{
												pos:  position{line: 464, col: 25, offset: 21375},
												name: "e0",
											},
											textCapture: true,
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "st_name1",
			pos:  position{line: 467, col: 1, offset: 21428},
			expr: &actionExpr{
				pos: position{line: 467, col: 13, offset: 21440},
				run: (*parser).callonst_name11,
				expr: &labeledExpr{
					pos:   position{line: 467, col: 13, offset: 21440},
					label: "text",
					expr: &seqExpr{
						pos: position{line: 467, col: 21, offset: 21448},
						exprs: []any{
							&oneOrMoreExpr{
								pos: position{line: 467, col: 21, offset: 21448},
								expr: &ruleRefExpr{
									pos:  position{line: 467, col: 21, offset: 21448},
									name: "id_ch0",
								},
							},
							&litMatcher{
								pos:        position{line: 467, col: 29, offset: 21456},
								val:        ":",
								ignoreCase: false,
								want:       "\":\"",
							},
							&oneOrMoreExpr{
								pos: position{line: 467, col: 33, offset: 21460},
								expr: &ruleRefExpr{
									pos:  position{line: 467, col: 33, offset: 21460},
									name: "id_ch0",
								},
							},
						},
					},
					textCapture: true,
				},
			},
		},
		{
			name: "st_name1r",
			pos:  position{line: 468, col: 1, offset: 21527},
			expr: &actionExpr{
				pos: position{line: 468, col: 14, offset: 21540},
				run: (*parser).callonst_name1r1,
				expr: &labeledExpr{
					pos:   position{line: 468, col: 14, offset: 21540},
					label: "text",
					expr: &oneOrMoreExpr{
						pos: position{line: 468, col: 23, offset: 21549},
						expr: &ruleRefExpr{
							pos:  position{line: 468, col: 23, offset: 21549},
							name: "id_ch0",
						},
					},
					textCapture: true,
				},
			},
		},
		{
			name: "st_name2",
			pos:  position{line: 470, col: 1, offset: 21617},
			expr: &actionExpr{
				pos: position{line: 470, col: 13, offset: 21629},
				run: (*parser).callonst_name21,
				expr: &labeledExpr{
					pos:   position{line: 470, col: 13, offset: 21629},
					label: "text",
					expr: &seqExpr{
						pos: position{line: 470, col: 21, offset: 21637},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 470, col: 21, offset: 21637},
								name: "id_ch0",
							},
							&zeroOrMoreExpr{
								pos: position{line: 470, col: 28, offset: 21644},
								expr: &ruleRefExpr{
									pos:  position{line: 470, col: 28, offset: 21644},
									name: "id_ch",
								},
							},
							&seqExpr{
								pos: position{line: 470, col: 36, offset: 21652},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 470, col: 36, offset: 21652},
										val:        ":",
										ignoreCase: false,
										want:       "\":\"",
									},
									&oneOrMoreExpr{
										pos: position{line: 470, col: 40, offset: 21656},
										expr: &ruleRefExpr{
											pos:  position{line: 470, col: 40, offset: 21656},
											name: "id_ch",
										},
									},
								},
							},
						},
					},
					textCapture: true,
				},
			},
		},
		{
			name: "st_name2r",
			pos:  position{line: 471, col: 1, offset: 21744},
			expr: &choiceExpr{
				pos: position{line: 471, col: 14, offset: 21757},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 471, col: 14, offset: 21757},
						run: (*parser).callonst_name2r2,
						expr: &labeledExpr{
							pos:   position{line: 471, col: 14, offset: 21757},
							label: "text",
							expr: &seqExpr{
								pos: position{line: 471, col: 22, offset: 21765},
								exprs: []any{
									&ruleRefExpr{
										pos:  position{line: 471, col: 22, offset: 21765},
										name: "id_ch0",
									},
									&zeroOrMoreExpr{
										pos: position{line: 471, col: 29, offset: 21772},
										expr: &ruleRefExpr{
											pos:  position{line: 471, col: 29, offset: 21772},
											name: "id_ch",
										},
									},
								},
							},
							textCapture: true,
						},
					},
					&actionExpr{
						pos: position{line: 472, col: 14, offset: 21872},
						run: (*parser).callonst_name2r8,
						expr: &seqExpr{
							pos: position{line: 472, col: 14, offset: 21872},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 472, col: 14, offset: 21872},
									val:        "'",
									ignoreCase: false,
									want:       "\"'\"",
								},
								&labeledExpr{
									pos:   position{line: 472, col: 19, offset: 21877},
									label: "text",
									expr: &oneOrMoreExpr{
										pos: position{line: 472, col: 26, offset: 21884},
										expr: &choiceExpr{
											pos: position{line: 472, col: 27, offset: 21885},
											alternatives: []any{
												&ruleRefExpr{
													pos:  position{line: 472, col: 27, offset: 21885},
													name: "id_ch0",
												},
												&charClassMatcher{
													pos:        position{line: 472, col: 36, offset: 21894},
													val:        "[0-9]",
													ranges:     []rune{'0', '9'},
													ignoreCase: false,
													inverted:   false,
												},
												&litMatcher{
													pos:        position{line: 472, col: 44, offset: 21902},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
												&litMatcher{
													pos:        position{line: 472, col: 50, offset: 21908},
													val:        ":",
													ignoreCase: false,
													want:       "\":\"",
												},
											},
										},
									},
									textCapture: true,
								},
								&litMatcher{
									pos:        position{line: 472, col: 58, offset: 21916},
									val:        "'",
									ignoreCase: false,
									want:       "\"'\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "id_ch0",
			pos:  position{line: 474, col: 1, offset: 21972},
			expr: &ruleRefExpr{
				pos:  position{line: 474, col: 11, offset: 21982},
				name: "xidStart",
			},
		},
		{
			name: "id_ch",
			pos:  position{line: 475, col: 1, offset: 21991},
			expr: &ruleRefExpr{
				pos:  position{line: 475, col: 10, offset: 22000},
				name: "xidStart",
			},
		},
	},
}

func (c *current) ondicescript1(p *parser) any {
	c.data.AddOp(typeHalt)
	return nil
	return c.text
}

func (p *parser) callondicescript1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ondicescript1(p)
}

func (c *current) onstmtLines3() bool {
	return !c.data.Config.DisableStmts
}

func (p *parser) callonstmtLines3() bool {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtLines3()
}

func (c *current) onflagsSwitch1(p *parser, id, on any) any {
	onVal := on == "true"
	switch id.(string) {
	case "wod":
		c.data.Config.EnableDiceWoD = onVal
	case "coc":
		c.data.Config.EnableDiceCoC = onVal
	case "fate":
		c.data.Config.EnableDiceFate = onVal
	case "doublecross":
		c.data.Config.EnableDiceDoubleCross = onVal
	}
	return c.text
}

func (p *parser) callonflagsSwitch1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onflagsSwitch1(p, stack["id"], stack["on"])
}

func (c *current) onstmtBreak1(p *parser) any {
	if c.data.loopLayer == 0 {
		panic("`break` is not allowed outside loop.")
	} else {
		c.data.BreakPush()
	}
	return c.text
}

func (p *parser) callonstmtBreak1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtBreak1(p)
}

func (c *current) onstmtContinue1(p *parser) any {
	if c.data.loopLayer == 0 {
		panic("`continue` is not allowed outside loop.")
	} else {
		c.data.ContinuePush()
	}
	return c.text
}

func (p *parser) callonstmtContinue1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtContinue1(p)
}

func (c *current) onstmtReturn2(p *parser) any {
	c.data.AddOp(typeReturn)
	return c.text
}

func (p *parser) callonstmtReturn2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtReturn2(p)
}

func (c *current) onstmtReturn7(p *parser) any {
	c.data.PushUndefined()
	c.data.AddOp(typeReturn)
	return c.text
}

func (p *parser) callonstmtReturn7() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtReturn7(p)
}

func (c *current) onstmtWhile2(p *parser) any {
	c.data.LoopBegin()
	c.data.OffsetPush()
	return c.text
}

func (p *parser) callonstmtWhile2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtWhile2(p)
}

func (c *current) onstmtWhile4(p *parser) any {
	c.data.AddOp(typeJne)
	c.data.OffsetPush()
	return c.text
}

func (p *parser) callonstmtWhile4() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtWhile4(p)
}

func (c *current) onstmtWhile8(p *parser) any {
	c.data.AddOp(typeJmp)
	c.data.OffsetPush()
	c.data.OffsetJmpSetX(0, 2, true)
	c.data.OffsetJmpSetX(1, 1, false)
	c.data.ContinueSet(2)
	c.data.BreakSet()
	c.data.OffsetPopN(3)
	c.data.LoopEnd()
	return c.text
}

func (p *parser) callonstmtWhile8() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtWhile8(p)
}

func (c *current) onstmtIf2(p *parser) any {
	c.data.AddOp(typeJne)
	c.data.OffsetPush()
	return c.text
}

func (p *parser) callonstmtIf2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtIf2(p)
}

func (c *current) onstmtIf7(p *parser) any {
	c.data.AddOp(typeJmp)
	c.data.OffsetPopAndSet()
	c.data.OffsetPush()
	return c.text
}

func (p *parser) callonstmtIf7() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtIf7(p)
}

func (c *current) onstmtIf9(p *parser) any {
	c.data.OffsetPopAndSet()
	return c.text
}

func (p *parser) callonstmtIf9() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtIf9(p)
}

func (c *current) onfunc_def_params2(p *parser) any {
	c.data.CounterPush()
	return c.text
}

func (p *parser) callonfunc_def_params2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfunc_def_params2(p)
}

func (c *current) onfunc_def_params9(p *parser) any {
	c.data.CounterPush()
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonfunc_def_params9() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfunc_def_params9(p)
}

func (c *current) onfunc_def_params13(p *parser, id any) any {
	c.data.NamePush(id.(string))
	return c.text
}

func (p *parser) callonfunc_def_params13() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfunc_def_params13(p, stack["id"])
}

func (c *current) onfunc_def_params21(p *parser, id2 any) any {
	c.data.NamePush(id2.(string))
	return c.text
}

func (p *parser) callonfunc_def_params21() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfunc_def_params21(p, stack["id2"])
}

func (c *current) onfunc_def_params28(p *parser, id2 any) any {
	c.data.CounterAdd(1)
	return nil
}

func (p *parser) callonfunc_def_params28() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfunc_def_params28(p, stack["id2"])
}

func (c *current) onstmtFunc2(p *parser, id any) any {
	c.data.NamePush(id.(string))
	return c.text
}

func (p *parser) callonstmtFunc2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtFunc2(p, stack["id"])
}

func (c *current) onstmtFunc9(p *parser, id any) any {
	c.data.CodePush()
	return c.text
}

func (p *parser) callonstmtFunc9() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtFunc9(p, stack["id"])
}

func (c *current) onstmtFunc14(p *parser, id, exprText any) any {
	num := c.data.CounterPop()
	arr := []string{}
	for i := IntType(0); i < num; i++ {
		arr = append(arr, c.data.NamePop())
	}
	c.data.AddStoreFunction(c.data.NamePop(), arr, exprText.(string))
	return c.text
}

func (p *parser) callonstmtFunc14() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtFunc14(p, stack["id"], stack["exprText"])
}

func (c *current) onstmtAssignType12(p *parser, id any) any {
	c.data.NamePush(id.(string))
	return c.text
}

func (p *parser) callonstmtAssignType12() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType12(p, stack["id"])
}

func (c *current) onstmtAssignType17(p *parser, id any) any {
	c.data.AddStore(c.data.NamePop())
	return c.text
}

func (p *parser) callonstmtAssignType17() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType17(p, stack["id"])
}

func (c *current) onstmtAssignType22(p *parser, id any) any {
	c.data.NamePush(id.(string))
	return c.text
}

func (p *parser) callonstmtAssignType22() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType22(p, stack["id"])
}

func (c *current) onstmtAssignType28(p *parser, id any) any {
	c.data.CodePush()
	return c.text
}

func (p *parser) callonstmtAssignType28() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType28(p, stack["id"])
}

func (c *current) onstmtAssignType212(p *parser, id, expr any) any {
	c.data.AddStoreComputed(c.data.NamePop(), expr.(string))
	return c.text
}

func (p *parser) callonstmtAssignType212() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType212(p, stack["id"], stack["expr"])
}

func (c *current) onstmtAssignType32(p *parser, id any) any {
	c.data.NamePush(id.(string))
	return c.text
}

func (p *parser) callonstmtAssignType32() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType32(p, stack["id"])
}

func (c *current) onstmtAssignType38(p *parser, id, id2 any) any {
	c.data.NamePush(id2.(string))
	return c.text
}

func (p *parser) callonstmtAssignType38() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType38(p, stack["id"], stack["id2"])
}

func (c *current) onstmtAssignType314(p *parser, id, id2 any) any {
	attr, objName := c.data.NamePop(), c.data.NamePop()
	c.data.AddAttrSet(objName, attr, true)
	return c.text
}

func (p *parser) callonstmtAssignType314() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType314(p, stack["id"], stack["id2"])
}

func (c *current) onstmtAssignType42(p *parser, id any) any {
	c.data.NamePush(id.(string))
	return c.text
}

func (p *parser) callonstmtAssignType42() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType42(p, stack["id"])
}

func (c *current) onstmtAssignType411(p *parser, id any) any {
	c.data.AddStoreLocal(c.data.NamePop())
	return c.text
}

func (p *parser) callonstmtAssignType411() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType411(p, stack["id"])
}

func (c *current) onstmtAssignType52(p *parser, id any) any {
	c.data.NamePush(id.(string))
	return c.text
}

func (p *parser) callonstmtAssignType52() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType52(p, stack["id"])
}

func (c *current) onstmtAssignType57(p *parser, id, id2 any) any {
	c.data.NamePush(id2.(string))
	return c.text
}

func (p *parser) callonstmtAssignType57() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType57(p, stack["id"], stack["id2"])
}

func (c *current) onstmtAssignType514(p *parser, id, id2 any) any {
	attr, objName := c.data.NamePop(), c.data.NamePop()
	c.data.AddAttrSet(objName, attr, false)
	return c.text
}

func (p *parser) callonstmtAssignType514() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType514(p, stack["id"], stack["id2"])
}

func (c *current) onstmtAssignType61(p *parser) any {
	c.data.AddOp(typeItemSet)
	return c.text
}

func (p *parser) callonstmtAssignType61() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType61(p)
}

func (c *current) onstmtAssignType71(p *parser) any {
	c.data.AddOp(typeSliceSet)
	return c.text
}

func (p *parser) callonstmtAssignType71() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstmtAssignType71(p)
}

func (c *current) on_step7(p *parser) any {
	c.data.PushUndefined()
	return c.text
}

func (p *parser) callon_step7() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_step7(p)
}

func (c *current) on_step9(p *parser) any {
	c.data.PushUndefined()
	return c.text
}

func (p *parser) callon_step9() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_step9(p)
}

func (c *current) on_sliceSuffix6(p *parser) any {
	c.data.PushUndefined()
	return c.text
}

func (p *parser) callon_sliceSuffix6() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_sliceSuffix6(p)
}

func (c *current) on_sliceSuffix12(p *parser) any {
	c.data.PushUndefined()
	return c.text
}

func (p *parser) callon_sliceSuffix12() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_sliceSuffix12(p)
}

func (c *current) onexprSliceType11(p *parser) any {
	c.data.AddOp(typeSliceGet)
	return c.text
}

func (p *parser) callonexprSliceType11() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprSliceType11(p)
}

func (c *current) onexprValueIfExists2(p *parser) any {
	c.data.AddOp(typeJne)
	c.data.OffsetPush()
	return c.text
}

func (p *parser) callonexprValueIfExists2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprValueIfExists2(p)
}

func (c *current) onexprValueIfExists8(p *parser) any {
	c.data.AddOp(typeJmp)
	c.data.OffsetPopAndSet()
	c.data.OffsetPush()
	return c.text
}

func (p *parser) callonexprValueIfExists8() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprValueIfExists8(p)
}

func (c *current) onexprTernaryType12(p *parser) any {
	c.data.AddOp(typeJne)
	c.data.OffsetPush()
	return c.text
}

func (p *parser) callonexprTernaryType12() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprTernaryType12(p)
}

func (c *current) onexprTernaryType18(p *parser) any {
	c.data.AddOp(typeJmp)
	c.data.OffsetPopAndSet()
	c.data.OffsetPush()
	return c.text
}

func (p *parser) callonexprTernaryType18() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprTernaryType18(p)
}

func (c *current) onexprTernaryType114(p *parser) any {
	c.data.OffsetPopAndSet()
	return c.text
}

func (p *parser) callonexprTernaryType114() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprTernaryType114(p)
}

func (c *current) onexprTernaryType22(p *parser) any {
	c.data.CounterPush()
	return c.text
}

func (p *parser) callonexprTernaryType22() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprTernaryType22(p)
}

func (c *current) onexprTernaryType26(p *parser) any {
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonexprTernaryType26() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprTernaryType26(p)
}

func (c *current) onexprTernaryType24(p *parser) any {
	c.data.PushStr("")
	limit := c.data.CounterPop() + 1
	for i := IntType(0); i < limit; i++ {
		c.data.OffsetPopAndSet()
	}
	return c.text
}

func (p *parser) callonexprTernaryType24() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprTernaryType24(p)
}

func (c *current) onexprLogicOr6(p *parser) any {
	c.data.AddOp(typeJeDup)
	c.data.OffsetPush()
	return c.text
}

func (p *parser) callonexprLogicOr6() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprLogicOr6(p)
}

func (c *current) onexprLogicOr8(p *parser) any {
	c.data.AddOp(typeJeDup)
	c.data.OffsetPush()
	return c.text
}

func (p *parser) callonexprLogicOr8() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprLogicOr8(p)
}

func (c *current) onexprLogicOr10(p *parser) any {
	c.data.AddOp(typePushLast)
	c.data.OffsetPopAndSet()
	c.data.OffsetPopAndSet()
	return nil
}

func (p *parser) callonexprLogicOr10() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprLogicOr10(p)
}

func (c *current) onexprLogicAnd5(p *parser) any {
	c.data.AddOp(typeLogicAnd)
	return c.text
}

func (p *parser) callonexprLogicAnd5() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprLogicAnd5(p)
}

func (c *current) onexprBitwiseOr3() bool {
	return c.data.Config.DisableBitwiseOp
}

func (p *parser) callonexprBitwiseOr3() bool {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprBitwiseOr3()
}

func (c *current) onexprBitwiseOr9(p *parser) any {
	c.data.AddOp(typeBitwiseOr)
	return c.text
}

func (p *parser) callonexprBitwiseOr9() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprBitwiseOr9(p)
}

func (c *current) onexprBitwiseAnd5(p *parser) any {
	c.data.AddOp(typeBitwiseAnd)
	return c.text
}

func (p *parser) callonexprBitwiseAnd5() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprBitwiseAnd5(p)
}

func (c *current) onexprCompare6(p *parser) any {
	c.data.AddOp(typeCompLT)
	return c.text
}

func (p *parser) callonexprCompare6() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprCompare6(p)
}

func (c *current) onexprCompare10(p *parser) any {
	c.data.AddOp(typeCompLE)
	return c.text
}

func (p *parser) callonexprCompare10() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprCompare10(p)
}

func (c *current) onexprCompare14(p *parser) any {
	c.data.AddOp(typeCompEQ)
	return c.text
}

func (p *parser) callonexprCompare14() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprCompare14(p)
}

func (c *current) onexprCompare18(p *parser) any {
	c.data.AddOp(typeCompNE)
	return c.text
}

func (p *parser) callonexprCompare18() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprCompare18(p)
}

func (c *current) onexprCompare22(p *parser) any {
	c.data.AddOp(typeCompGE)
	return c.text
}

func (p *parser) callonexprCompare22() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprCompare22(p)
}

func (c *current) onexprCompare26(p *parser) any {
	c.data.AddOp(typeCompGT)
	return c.text
}

func (p *parser) callonexprCompare26() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprCompare26(p)
}

func (c *current) onexprAdditive6(p *parser) any {
	c.data.AddOp(typeAdd)
	return c.text
}

func (p *parser) callonexprAdditive6() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprAdditive6(p)
}

func (c *current) onexprAdditive10(p *parser) any {
	c.data.AddOp(typeSubtract)
	return c.text
}

func (p *parser) callonexprAdditive10() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprAdditive10(p)
}

func (c *current) onexprMultiplicative6(p *parser) any {
	c.data.AddOp(typeMultiply)
	return c.text
}

func (p *parser) callonexprMultiplicative6() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprMultiplicative6(p)
}

func (c *current) onexprMultiplicative10(p *parser) any {
	c.data.AddOp(typeDivide)
	return c.text
}

func (p *parser) callonexprMultiplicative10() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprMultiplicative10(p)
}

func (c *current) onexprMultiplicative14(p *parser) any {
	c.data.AddOp(typeModulus)
	return c.text
}

func (p *parser) callonexprMultiplicative14() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprMultiplicative14(p)
}

func (c *current) onexprNullCoalescing5(p *parser) any {
	c.data.AddOp(typeNullCoalescing)
	return c.text
}

func (p *parser) callonexprNullCoalescing5() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprNullCoalescing5(p)
}

func (c *current) onexprExp5(p *parser) any {
	c.data.AddOp(typeExponentiation)
	return c.text
}

func (p *parser) callonexprExp5() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprExp5(p)
}

func (c *current) onexprUnaryNeg2(p *parser) any {
	c.data.AddOp(typeNegation)
	return c.text
}

func (p *parser) callonexprUnaryNeg2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprUnaryNeg2(p)
}

func (c *current) onexprUnaryPos2(p *parser) any {
	c.data.AddOp(typePositive)
	return c.text
}

func (p *parser) callonexprUnaryPos2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprUnaryPos2(p)
}

func (c *current) ondetailStart1(p *parser) any {
	c.data.CounterPush()
	c.data.CounterAdd(IntType(p.pt.offset))
	return nil
}

func (p *parser) callondetailStart1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ondetailStart1(p)
}

func (c *current) ondetailEnd1(p *parser) any {
	c.data.AddDiceDetail(c.data.CounterPop(), IntType(p.pt.offset))
	return nil
}

func (p *parser) callondetailEnd1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ondetailEnd1(p)
}

func (c *current) on_diceMod2(p *parser) any {
	c.data.AddOp(typeDiceSetKeepLowNum)
	return c.text
}

func (p *parser) callon_diceMod2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceMod2(p)
}

func (c *current) on_diceMod8(p *parser) any {
	c.data.PushIntNumber("1")
	c.data.AddOp(typeDiceSetKeepLowNum)
	return c.text
}

func (p *parser) callon_diceMod8() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceMod8(p)
}

func (c *current) on_diceMod12(p *parser) any {
	c.data.AddOp(typeDiceSetKeepHighNum)
	return c.text
}

func (p *parser) callon_diceMod12() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceMod12(p)
}

func (c *current) on_diceMod18(p *parser) any {
	c.data.PushIntNumber("1")
	c.data.AddOp(typeDiceSetKeepHighNum)
	return c.text
}

func (p *parser) callon_diceMod18() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceMod18(p)
}

func (c *current) on_diceMod22(p *parser) any {
	c.data.AddOp(typeDiceSetDropHighNum)
	return c.text
}

func (p *parser) callon_diceMod22() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceMod22(p)
}

func (c *current) on_diceMod26(p *parser) any {
	c.data.PushIntNumber("1")
	c.data.AddOp(typeDiceSetDropHighNum)
	return c.text
}

func (p *parser) callon_diceMod26() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceMod26(p)
}

func (c *current) on_diceMod28(p *parser) any {
	c.data.AddOp(typeDiceSetDropLowNum)
	return c.text
}

func (p *parser) callon_diceMod28() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceMod28(p)
}

func (c *current) on_diceMod32(p *parser) any {
	c.data.PushIntNumber("1")
	c.data.AddOp(typeDiceSetDropLowNum)
	return c.text
}

func (p *parser) callon_diceMod32() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceMod32(p)
}

func (c *current) on_diceModType22(p *parser) any {
	c.data.AddOp(typeDiceSetMin)
	return c.text
}

func (p *parser) callon_diceModType22() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceModType22(p)
}

func (c *current) on_diceModType26(p *parser) any {
	c.data.AddOp(typeDiceSetMax)
	return c.text
}

func (p *parser) callon_diceModType26() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceModType26(p)
}

func (c *current) on_dicePearMod2(p *parser) any {
	c.data.PushIntNumber("2")
	c.data.AddOp(typeDiceSetTimes)
	c.data.PushIntNumber("1")
	c.data.AddOp(typeDiceSetKeepHighNum)
	return c.text
}

func (p *parser) callon_dicePearMod2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_dicePearMod2(p)
}

func (c *current) on_dicePearMod4(p *parser) any {
	c.data.PushIntNumber("2")
	c.data.AddOp(typeDiceSetTimes)
	c.data.PushIntNumber("1")
	c.data.AddOp(typeDiceSetKeepLowNum)
	return c.text
}

func (p *parser) callon_dicePearMod4() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_dicePearMod4(p)
}

func (c *current) on_diceExpr12(p *parser) any {
	c.data.AddOp(typeDiceInit)
	c.data.AddOp(typeDiceSetTimes)
	return nil
	return c.text
}

func (p *parser) callon_diceExpr12() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceExpr12(p)
}

func (c *current) on_diceExpr22(p *parser) any {
	c.data.AddOp(typeDiceInit)
	return c.text
}

func (p *parser) callon_diceExpr22() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceExpr22(p)
}

func (c *current) on_diceExpr32(p *parser) any {
	c.data.AddOp(typeDiceInit)
	c.data.AddOp(typeDiceSetTimes)
	return c.text
}

func (p *parser) callon_diceExpr32() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceExpr32(p)
}

func (c *current) on_diceExprX1(p *parser) any {
	c.data.AddOp(typeDice)
	return c.text
}

func (p *parser) callon_diceExprX1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceExprX1(p)
}

func (c *current) on_wodMain6(p *parser) any {
	c.data.AddOp(typeWodSetPoints)
	return c.text
}

func (p *parser) callon_wodMain6() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_wodMain6(p)
}

func (c *current) on_wodMain10(p *parser) any {
	c.data.AddOp(typeWodSetThreshold)
	return c.text
}

func (p *parser) callon_wodMain10() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_wodMain10(p)
}

func (c *current) on_wodMain14(p *parser) any {
	c.data.AddOp(typeWodSetThresholdQ)
	return c.text
}

func (p *parser) callon_wodMain14() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_wodMain14(p)
}

func (c *current) on_diceCocBonus9(p *parser) any {
	c.data.PushIntNumber("1")
	return c.text
}

func (p *parser) callon_diceCocBonus9() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceCocBonus9(p)
}

func (c *current) on_diceCocBonus1(p *parser) any {
	c.data.AddOp(typeDiceCocBonus)
	return c.text
}

func (p *parser) callon_diceCocBonus1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceCocBonus1(p)
}

func (c *current) on_diceCocPenalty9(p *parser) any {
	c.data.PushIntNumber("1")
	return c.text
}

func (p *parser) callon_diceCocPenalty9() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceCocPenalty9(p)
}

func (c *current) on_diceCocPenalty1(p *parser) any {
	c.data.AddOp(typeDiceCocPenalty)
	return c.text
}

func (p *parser) callon_diceCocPenalty1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_diceCocPenalty1(p)
}

func (c *current) onexprDice3(p *parser) any {
	c.data.AddOp(typeDice)
	return c.text
}

func (p *parser) callonexprDice3() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice3(p)
}

func (c *current) onexprDice14(p *parser) any {
	c.data.AddOp(typeDice)
	return c.text
}

func (p *parser) callonexprDice14() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice14(p)
}

func (c *current) onexprDice26() bool {
	return !c.data.Config.DisableNDice
}

func (p *parser) callonexprDice26() bool {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice26()
}

func (c *current) onexprDice24(p *parser) any {
	c.data.AddOp(typePushDefaultExpr)
	c.data.AddOp(typeDice)
	return c.text
}

func (p *parser) callonexprDice24() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice24(p)
}

func (c *current) onexprDice38() bool {
	return !c.data.Config.DisableNDice
}

func (p *parser) callonexprDice38() bool {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice38()
}

func (c *current) onexprDice36(p *parser) any {
	c.data.PushIntNumber("1")
	return c.text
}

func (p *parser) callonexprDice36() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice36(p)
}

func (c *current) onexprDice42(p *parser) any {
	c.data.AddOp(typePushDefaultExpr)
	c.data.AddOp(typeDice)
	return c.text
}

func (p *parser) callonexprDice42() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice42(p)
}

func (c *current) onexprDice49() bool {
	return c.data.Config.EnableDiceCoC
}

func (p *parser) callonexprDice49() bool {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice49()
}

func (c *current) onexprDice59() bool {
	return c.data.Config.EnableDiceWoD
}

func (p *parser) callonexprDice59() bool {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice59()
}

func (c *current) onexprDice57(p *parser) any {
	c.data.AddOp(typeWodSetInit)
	return c.text
}

func (p *parser) callonexprDice57() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice57(p)
}

func (c *current) onexprDice67(p *parser) any {
	c.data.AddOp(typeWodSetPool)
	return c.text
}

func (p *parser) callonexprDice67() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice67(p)
}

func (c *current) onexprDice63(p *parser) any {
	c.data.AddOp(typeDiceWod)
	return c.text
}

func (p *parser) callonexprDice63() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice63(p)
}

func (c *current) onexprDice78() bool {
	return c.data.Config.EnableDiceDoubleCross
}

func (p *parser) callonexprDice78() bool {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice78()
}

func (c *current) onexprDice76(p *parser) any {
	c.data.AddOp(typeDCSetInit)
	return c.text
}

func (p *parser) callonexprDice76() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice76(p)
}

func (c *current) onexprDice82(p *parser) any {
	c.data.AddOp(typeDCSetPool)
	return c.text
}

func (p *parser) callonexprDice82() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice82(p)
}

func (c *current) onexprDice89(p *parser) any {
	c.data.AddOp(typeDCSetPoints)
	return c.text
}

func (p *parser) callonexprDice89() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice89(p)
}

func (c *current) onexprDice84(p *parser) any {
	c.data.AddOp(typeDiceDC)
	return c.text
}

func (p *parser) callonexprDice84() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice84(p)
}

func (c *current) onexprDice96() bool {
	return c.data.Config.EnableDiceFate
}

func (p *parser) callonexprDice96() bool {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice96()
}

func (c *current) onexprDice94(p *parser) any {
	c.data.AddOp(typeDiceFate)
	return c.text
}

func (p *parser) callonexprDice94() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexprDice94(p)
}

func (c *current) onarray_call3(p *parser) any {
	c.data.WriteCode(typeGetAttr, string("kh"))
	return c.text
}

func (p *parser) callonarray_call3() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onarray_call3(p)
}

func (c *current) onarray_call6(p *parser) any {
	c.data.AddInvoke(1)
	return c.text
}

func (p *parser) callonarray_call6() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onarray_call6(p)
}

func (c *current) onarray_call8(p *parser) any {
	c.data.AddInvoke(0)
	return nil
}

func (p *parser) callonarray_call8() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onarray_call8(p)
}

func (c *current) onarray_call10(p *parser) any {
	c.data.WriteCode(typeGetAttr, string("kl"))
	return c.text
}

func (p *parser) callonarray_call10() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onarray_call10(p)
}

func (c *current) onarray_call13(p *parser) any {
	c.data.AddInvoke(1)
	return c.text
}

func (p *parser) callonarray_call13() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onarray_call13(p)
}

func (c *current) onarray_call15(p *parser) any {
	c.data.AddInvoke(0)
	return nil
}

func (p *parser) callonarray_call15() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onarray_call15(p)
}

func (c *current) onarray_call17(p *parser) any {
	c.data.AddOp(typeItemGet)
	return c.text
}

func (p *parser) callonarray_call17() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onarray_call17(p)
}

func (c *current) onitem_getX3(p *parser) any {
	c.data.AddOp(typeItemGet)
	return c.text
}

func (p *parser) callonitem_getX3() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onitem_getX3(p)
}

func (c *current) onattr_getX4(p *parser, id any) any {
	c.data.WriteCode(typeGetAttr, id.(string))
	return c.text
}

func (p *parser) callonattr_getX4() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onattr_getX4(p, stack["id"])
}

func (c *current) onfunc_invoke2(p *parser) any {
	c.data.AddInvoke(0)
	return c.text
}

func (p *parser) callonfunc_invoke2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfunc_invoke2(p)
}

func (c *current) onfunc_invoke9(p *parser) any {
	c.data.CounterPush()
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonfunc_invoke9() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfunc_invoke9(p)
}

func (c *current) onfunc_invoke17(p *parser) any {
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonfunc_invoke17() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfunc_invoke17(p)
}

func (c *current) onfunc_invoke13(p *parser) any {
	c.data.AddInvoke(c.data.CounterPop())
	return c.text
}

func (p *parser) callonfunc_invoke13() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfunc_invoke13(p)
}

func (c *current) ondict_item1(p *parser) any {
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callondict_item1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ondict_item1(p)
}

func (c *current) onvalue_id_without_colon2(p *parser, id any) any {
	c.data.WriteCode(typeLoadName, string(id.(string)))
	return c.text
}

func (p *parser) callonvalue_id_without_colon2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue_id_without_colon2(p, stack["id"])
}

func (c *current) onvalue_array_range1(p *parser) any {
	c.data.AddOp(typePushRange)
	return c.text
}

func (p *parser) callonvalue_array_range1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue_array_range1(p)
}

func (c *current) onvalue_array2(p *parser) any {
	c.data.CounterPush()
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonvalue_array2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue_array2(p)
}

func (c *current) onvalue_array10(p *parser) any {
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonvalue_array10() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue_array10(p)
}

func (c *current) onvalue_array6(p *parser) any {
	c.data.PushArray(c.data.CounterPop())
	return c.text
}

func (p *parser) callonvalue_array6() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue_array6(p)
}

func (c *current) onvalue2(p *parser) any {
	c.data.PushIntNumber("1")
	return c.text
}

func (p *parser) callonvalue2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue2(p)
}

func (c *current) onvalue6(p *parser) any {
	c.data.PushIntNumber("0")
	return c.text
}

func (p *parser) callonvalue6() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue6(p)
}

func (c *current) onvalue10(p *parser) any {
	c.data.PushUndefined()
	return c.text
}

func (p *parser) callonvalue10() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue10(p)
}

func (c *current) onvalue15(p *parser) any {
	c.data.PushThis()
	return c.text
}

func (p *parser) callonvalue15() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue15(p)
}

func (c *current) onvalue23(p *parser, id any) any {
	c.data.WriteCode(typeLoadNameRaw, id.(string))
	return c.text
}

func (p *parser) callonvalue23() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue23(p, stack["id"])
}

func (c *current) onvalue33(p *parser, id any) any {
	c.data.WriteCode(typeLoadNameWithDetail, id.(string))
	return c.text
}

func (p *parser) callonvalue33() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue33(p, stack["id"])
}

func (c *current) onvalue55(p *parser) any {
	c.data.PushArray(0)
	return c.text
}

func (p *parser) callonvalue55() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue55(p)
}

func (c *current) onvalue80(p *parser) any {
	c.data.PushDict(0)
	return c.text
}

func (p *parser) callonvalue80() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue80(p)
}

func (c *current) onvalue90(p *parser) any {
	c.data.CounterPush()
	return c.text
}

func (p *parser) callonvalue90() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue90(p)
}

func (c *current) onvalue94(p *parser) any {
	c.data.PushDict(c.data.CounterPop())
	return c.text
}

func (p *parser) callonvalue94() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onvalue94(p)
}

func (c *current) onnumber1(p *parser) any {
	c.data.PushIntNumber(toStr(c.text))
	return c.text
}

func (p *parser) callonnumber1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onnumber1(p)
}

func (c *current) onfloat1(p *parser) any {
	c.data.PushFloatNumber(toStr(c.text))
	return c.text
}

func (p *parser) callonfloat1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfloat1(p)
}

func (c *current) onstrPart1(p *parser, text any) any {
	c.data.PushStr(text.(string))
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonstrPart1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstrPart1(p, stack["text"])
}

func (c *current) onstrPart11(p *parser, text any) any {
	c.data.PushStr(text.(string))
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonstrPart11() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstrPart11(p, stack["text"])
}

func (c *current) onstrPart21(p *parser, text any) any {
	c.data.PushStr(text.(string))
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonstrPart21() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstrPart21(p, stack["text"])
}

func (c *current) onstrPart31(p *parser, text any) any {
	c.data.PushStr(text.(string))
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonstrPart31() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstrPart31(p, stack["text"])
}

func (c *current) onfstring3(p *parser) any {
	c.data.PushStr("")
	return c.text
}

func (p *parser) callonfstring3() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring3(p)
}

func (c *current) onfstring7(p *parser) any {
	c.data.PushStr("")
	return c.text
}

func (p *parser) callonfstring7() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring7(p)
}

func (c *current) onfstring11(p *parser) any {
	c.data.PushStr("")
	return c.text
}

func (p *parser) callonfstring11() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring11(p)
}

func (c *current) onfstring15(p *parser) any {
	c.data.PushStr("")
	return c.text
}

func (p *parser) callonfstring15() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring15(p)
}

func (c *current) onfstring20(p *parser) any {
	c.data.CounterPush()
	return c.text
}

func (p *parser) callonfstring20() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring20(p)
}

func (c *current) onfstring27(p *parser) any {
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonfstring27() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring27(p)
}

func (c *current) onfstring34(p *parser) any {
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonfstring34() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring34(p)
}

func (c *current) onfstring22(p *parser) any {
	c.data.AddFormatString(c.data.CounterPop())
	return c.text
}

func (p *parser) callonfstring22() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring22(p)
}

func (c *current) onfstring43(p *parser) any {
	c.data.CounterPush()
	return c.text
}

func (p *parser) callonfstring43() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring43(p)
}

func (c *current) onfstring50(p *parser) any {
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonfstring50() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring50(p)
}

func (c *current) onfstring57(p *parser) any {
	c.data.CounterAdd(1)
	return c.text
}

func (p *parser) callonfstring57() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring57(p)
}

func (c *current) onfstring45(p *parser) any {
	c.data.AddFormatString(c.data.CounterPop())
	return c.text
}

func (p *parser) callonfstring45() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring45(p)
}

func (c *current) onfstring66(p *parser) any {
	c.data.CounterPush()
	return c.text
}

func (p *parser) callonfstring66() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring66(p)
}

func (c *current) onfstring68(p *parser) any {
	c.data.CounterPop()
	return c.text
}

func (p *parser) callonfstring68() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring68(p)
}

func (c *current) onfstring74(p *parser) any {
	c.data.CounterPush()
	return c.text
}

func (p *parser) callonfstring74() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring74(p)
}

func (c *current) onfstring76(p *parser) any {
	c.data.CounterPop()
	return c.text
}

func (p *parser) callonfstring76() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfstring76(p)
}

func (c *current) onidentifier1(p *parser) any {
	return toStr(c.text)
	return c.text
}

func (p *parser) callonidentifier1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onidentifier1(p)
}

func (c *current) onidentifierWithoutColon1(p *parser) any {
	return toStr(c.text)
	return c.text
}

func (p *parser) callonidentifierWithoutColon1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onidentifierWithoutColon1(p)
}

func (c *current) onest7(p *parser) any {
	c.data.FlagsPush()
	c.data.Config.DisableStmts = true
	c.data.Config.DisableNDice = true
	return c.text
}

func (p *parser) callonest7() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onest7(p)
}

func (c *current) onest10(p *parser) any {
	c.data.FlagsPop()
	return c.text
}

func (p *parser) callonest10() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onest10(p)
}

func (c *current) onst_assign2(p *parser) any {
	c.data.AddStName()
	return c.text
}

func (p *parser) callonst_assign2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_assign2(p)
}

func (c *current) onst_assign11(p *parser) any {
	c.data.AddStName()
	return c.text
}

func (p *parser) callonst_assign11() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_assign11(p)
}

func (c *current) onst_assign15(p *parser) any {
	c.data.AddOp(typeStX1)
	return c.text
}

func (p *parser) callonst_assign15() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_assign15(p)
}

func (c *current) onst_assign26(p *parser) any {
	c.data.AddOp(typeStX0)
	return c.text
}

func (p *parser) callonst_assign26() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_assign26(p)
}

func (c *current) onst_assign37(p *parser) any {
	c.data.AddStName()
	return c.text
}

func (p *parser) callonst_assign37() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_assign37(p)
}

func (c *current) onst_assign46(p *parser) any {
	c.data.AddStName()
	return c.text
}

func (p *parser) callonst_assign46() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_assign46(p)
}

func (c *current) onst_assign51(p *parser) any {
	c.data.CodePush()
	return c.text
}

func (p *parser) callonst_assign51() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_assign51(p)
}

func (c *current) onst_assign60(p *parser, text any) any {
	c.data.CodePop()
	c.data.AddStoreComputedOnStack(text.(string))
	c.data.AddStName()
	return c.text
}

func (p *parser) callonst_assign60() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_assign60(p, stack["text"])
}

func (c *current) onst_assign64(p *parser) any {
	c.data.CodePush()
	return c.text
}

func (p *parser) callonst_assign64() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_assign64(p)
}

func (c *current) onst_assign73(p *parser, text any) any {
	c.data.CodePop()
	c.data.AddStoreComputedOnStack(text.(string))
	c.data.AddStName()
	return c.text
}

func (p *parser) callonst_assign73() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_assign73(p, stack["text"])
}

func (c *current) onst_modify_rest14(p *parser, text any) any {
	c.data.AddStModify("+", text.(string))
	return c.text
}

func (p *parser) callonst_modify_rest14() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_modify_rest14(p, stack["text"])
}

func (c *current) onst_modify_rest110(p *parser, text any) any {
	c.data.AddStModify("-", text.(string))
	return c.text
}

func (p *parser) callonst_modify_rest110() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_modify_rest110(p, stack["text"])
}

func (c *current) onst_modify_rest4(p *parser, text any) any {
	c.data.AddStModify("+", text.(string))
	return c.text
}

func (p *parser) callonst_modify_rest4() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_modify_rest4(p, stack["text"])
}

func (c *current) onst_modify_rest12(p *parser, text any) any {
	c.data.AddStModify("-", text.(string))
	return c.text
}

func (p *parser) callonst_modify_rest12() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_modify_rest12(p, stack["text"])
}

func (c *current) onst_modify_rest19(p *parser, text any) any {
	c.data.AddStModify("-", text.(string))
	return c.text
}

func (p *parser) callonst_modify_rest19() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_modify_rest19(p, stack["text"])
}

func (c *current) onst_name11(p *parser, text any) any {
	c.data.PushStr(text.(string))
	return c.text
}

func (p *parser) callonst_name11() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_name11(p, stack["text"])
}

func (c *current) onst_name1r1(p *parser, text any) any {
	c.data.PushStr(text.(string))
	return c.text
}

func (p *parser) callonst_name1r1() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_name1r1(p, stack["text"])
}

func (c *current) onst_name21(p *parser, text any) any {
	c.data.PushStr(text.(string))
	return c.text
}

func (p *parser) callonst_name21() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_name21(p, stack["text"])
}

func (c *current) onst_name2r2(p *parser, text any) any {
	c.data.PushStr(text.(string))
	return c.text
}

func (p *parser) callonst_name2r2() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_name2r2(p, stack["text"])
}

func (c *current) onst_name2r8(p *parser, text any) any {
	c.data.PushStr(text.(string))
	return c.text
}

func (p *parser) callonst_name2r8() any {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onst_name2r8(p, stack["text"])
}

var (
	// errNoRule is returned when the grammar to parse has no rule.
	errNoRule = errors.New("grammar has no rule")

	// errInvalidEntrypoint is returned when the specified entrypoint rule
	// does not exit.
	errInvalidEntrypoint = errors.New("invalid entrypoint")

	// errInvalidEncoding is returned when the source is not properly
	// utf8-encoded.
	errInvalidEncoding = errors.New("invalid encoding")

	// errMaxExprCnt is used to signal that the maximum number of
	// expressions have been parsed.
	errMaxExprCnt = errors.New("max number of expressions parsed")
)

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*parser) Option

// maxExpressions creates an Option to stop parsing after the provided
// number of expressions have been parsed, if the value is 0 then the parser will
// parse for as many steps as needed (possibly an infinite number).
//
// The default for maxExprCnt is 0.
func maxExpressions(maxExprCnt uint64) Option {
	return func(p *parser) Option {
		oldMaxExprCnt := p.maxExprCnt
		p.maxExprCnt = maxExprCnt
		return maxExpressions(oldMaxExprCnt)
	}
}

// entrypoint creates an Option to set the rule name to use as entrypoint.
// The rule name must have been specified in the -alternate-entrypoints
// if generating the parser with the -optimize-grammar flag, otherwise
// it may have been optimized out. Passing an empty string sets the
// entrypoint to the first rule in the grammar.
//
// The default is to start parsing at the first rule in the grammar.
func entrypoint(ruleName string) Option {
	return func(p *parser) Option {
		oldEntrypoint := p.entrypoint
		p.entrypoint = ruleName
		if ruleName == "" {
			p.entrypoint = g.rules[0].name
		}
		return entrypoint(oldEntrypoint)
	}
}

// allowInvalidUTF8 creates an Option to allow invalid UTF-8 bytes.
// Every invalid UTF-8 byte is treated as a utf8.RuneError (U+FFFD)
// by character class matchers and is matched by the any matcher.
// The returned matched value, c.text and c.offset are NOT affected.
//
// The default is false.
func allowInvalidUTF8(b bool) Option {
	return func(p *parser) Option {
		old := p.allowInvalidUTF8
		p.allowInvalidUTF8 = b
		return allowInvalidUTF8(old)
	}
}

// recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func recoverOption(b bool) Option {
	return func(p *parser) Option {
		old := p.recover
		p.recover = b
		return recoverOption(old)
	}
}

// globalStore creates an Option to set a key to a certain value in
// the globalStore.
func globalStore(key string, value any) Option {
	return func(p *parser) Option {
		old := p.cur.globalStore[key]
		p.cur.globalStore[key] = value
		return globalStore(key, old)
	}
}

// Parse parses the data from b using filename as information in the
// error messages.
func parse(filename string, b []byte, opts ...Option) (any, error) {
	return newParser(filename, b, opts...).parse(g)
}

// position records a position in the text.
type position struct {
	line, col, offset int
}

func (p position) String() string {
	return strconv.Itoa(p.line) + ":" + strconv.Itoa(p.col) + " [" + strconv.Itoa(p.offset) + "]"
}

// savepoint stores all state required to go back to this point in the
// parser.
type savepoint struct {
	position
	rn rune
	w  int
}

type current struct {
	pos  position // start position of the match
	text []byte   // raw text of the match

	// globalStore is a general store for the user to store arbitrary key-value
	// pairs that they need to manage and that they do not want tied to the
	// backtracking of the parser. This is only modified by the user and never
	// rolled back by the parser. It is always up to the user to keep this in a
	// consistent state.
	globalStore storeDict

	data *ParserCustomData
}

type storeDict map[string]any

// the AST types...

// nolint: structcheck
type grammar struct {
	pos   position
	rules []*rule
}

// nolint: structcheck
type rule struct {
	pos         position
	name        string
	displayName string
	expr        any
}

// nolint: structcheck
type choiceExpr struct {
	pos          position
	alternatives []any
}

// nolint: structcheck
type actionExpr struct {
	pos  position
	expr any
	run  func(*parser) any
}

// nolint: structcheck
type recoveryExpr struct {
	pos          position
	expr         any
	recoverExpr  any
	failureLabel []string
}

// nolint: structcheck
type seqExpr struct {
	pos   position
	exprs []any
}

// nolint: structcheck
type throwExpr struct {
	pos   position
	label string
}

// nolint: structcheck
type labeledExpr struct {
	pos         position
	label       string
	expr        any
	textCapture bool
}

// nolint: structcheck
type expr struct {
	pos  position
	expr any
}

type (
	andExpr        expr // nolint: structcheck
	notExpr        expr // nolint: structcheck
	andLogicalExpr expr // nolint: structcheck
	notLogicalExpr expr // nolint: structcheck
	zeroOrOneExpr  expr // nolint: structcheck
	zeroOrMoreExpr expr // nolint: structcheck
	oneOrMoreExpr  expr // nolint: structcheck
)

// nolint: structcheck
type ruleRefExpr struct {
	pos  position
	name string
}

// nolint: structcheck
type andCodeExpr struct {
	pos position
	run func(*parser) bool
}

// nolint: structcheck
type notCodeExpr struct {
	pos position
	run func(*parser) bool
}

// nolint: structcheck
type litMatcher struct {
	pos        position
	val        string
	ignoreCase bool
	want       string
}

// nolint: structcheck
type codeExpr struct {
	pos     position
	run     func(*parser) any
	notSkip bool
}

// nolint: structcheck
type charClassMatcher struct {
	pos             position
	val             string
	basicLatinChars [128]bool
	chars           []rune
	ranges          []rune
	classes         []*unicode.RangeTable
	ignoreCase      bool
	inverted        bool
}

type anyMatcher position // nolint: structcheck

// errList cumulates the errors found by the parser.
type errList []error

func (e *errList) add(err error) {
	*e = append(*e, err)
}

func (e errList) err() error {
	if len(e) == 0 {
		return nil
	}
	e.dedupe()
	return e
}

func (e *errList) dedupe() {
	var cleaned []error
	set := make(map[string]bool)
	for _, err := range *e {
		if msg := err.Error(); !set[msg] {
			set[msg] = true
			cleaned = append(cleaned, err)
		}
	}
	*e = cleaned
}

func (e errList) Error() string {
	switch len(e) {
	case 0:
		return ""
	case 1:
		return e[0].Error()
	default:
		var buf bytes.Buffer

		for i, err := range e {
			if i > 0 {
				buf.WriteRune('\n')
			}
			buf.WriteString(err.Error())
		}
		return buf.String()
	}
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
type parserError struct {
	Inner    error
	pos      position
	prefix   string
	expected []string
}

// Error returns the error message.
func (p *parserError) Error() string {
	return p.prefix + ": " + p.Inner.Error()
}

// newParser creates a parser with the specified input source and options.
func newParser(filename string, b []byte, opts ...Option) *parser {
	stats := Stats{
		ChoiceAltCnt: make(map[string]map[string]int),
	}

	p := &parser{
		filename: filename,
		errs:     new(errList),
		data:     b,
		pt:       savepoint{position: position{line: 1}},
		recover:  true,
		cur: current{
			globalStore: make(storeDict),
			data:        &ParserCustomData{},
		},
		maxFailPos:      position{col: 1, line: 1},
		maxFailExpected: make([]string, 0, 20),
		Stats:           &stats,
		// start rule is rule [0] unless an alternate entrypoint is specified
		entrypoint: g.rules[0].name,
		scStack:    []bool{false},
	}
	p.setOptions(opts)

	if p.maxExprCnt == 0 {
		p.maxExprCnt = math.MaxUint64
	}

	return p
}

// setCustomData to the parser.
func (p *parser) setCustomData(data *ParserCustomData) {
	p.cur.data = data
}

// setOptions applies the options to the parser.
func (p *parser) setOptions(opts []Option) {
	for _, opt := range opts {
		opt(p)
	}
}

func (p *parser) checkSkipCode() bool {
	return p.scStack[len(p.scStack)-1]
}

// nolint: structcheck,deadcode
type resultTuple struct {
	v   any
	b   bool
	end savepoint
}

// nolint: varcheck
const choiceNoMatch = -1

// Stats stores some statistics, gathered during parsing
type Stats struct {
	// ExprCnt counts the number of expressions processed during parsing
	// This value is compared to the maximum number of expressions allowed
	// (set by the MaxExpressions option).
	ExprCnt uint64

	// ChoiceAltCnt is used to count for each ordered choice expression,
	// which alternative is used how may times.
	// These numbers allow to optimize the order of the ordered choice expression
	// to increase the performance of the parser
	//
	// The outer key of ChoiceAltCnt is composed of the name of the rule as well
	// as the line and the column of the ordered choice.
	// The inner key of ChoiceAltCnt is the number (one-based) of the matching alternative.
	// For each alternative the number of matches are counted. If an ordered choice does not
	// match, a special counter is incremented. The name of this counter is set with
	// the parser option Statistics.
	// For an alternative to be included in ChoiceAltCnt, it has to match at least once.
	ChoiceAltCnt map[string]map[string]int
}

// nolint: structcheck,maligned
type parser struct {
	filename string
	pt       savepoint
	cur      current

	data []byte
	errs *errList

	depth   int
	recover bool

	// rules table, maps the rule identifier to the rule node
	rules map[string]*rule
	// variables stack, map of label to value
	vstack []map[string]any
	// rule stack, allows identification of the current rule in errors
	rstack []*rule

	// parse fail
	maxFailPos            position
	maxFailExpected       []string
	maxFailInvertExpected bool

	// max number of expressions to be parsed
	maxExprCnt uint64
	// entrypoint for the parser
	entrypoint string

	allowInvalidUTF8 bool

	*Stats

	choiceNoMatch string
	// recovery expression stack, keeps track of the currently available recovery expression, these are traversed in reverse
	recoveryStack []map[string]any

	_errPos *position
	// skip code stack
	scStack []bool
}

// push a variable set on the vstack.
func (p *parser) pushV() {
	if cap(p.vstack) == len(p.vstack) {
		// create new empty slot in the stack
		p.vstack = append(p.vstack, nil)
	} else {
		// slice to 1 more
		p.vstack = p.vstack[:len(p.vstack)+1]
	}

	// get the last args set
	m := p.vstack[len(p.vstack)-1]
	if m != nil && len(m) == 0 {
		// empty map, all good
		return
	}

	m = make(map[string]any)
	p.vstack[len(p.vstack)-1] = m
}

// pop a variable set from the vstack.
func (p *parser) popV() {
	// if the map is not empty, clear it
	m := p.vstack[len(p.vstack)-1]
	if len(m) > 0 {
		// GC that map
		p.vstack[len(p.vstack)-1] = nil
	}
	p.vstack = p.vstack[:len(p.vstack)-1]
}

// push a recovery expression with its labels to the recoveryStack
func (p *parser) pushRecovery(labels []string, expr any) {
	if cap(p.recoveryStack) == len(p.recoveryStack) {
		// create new empty slot in the stack
		p.recoveryStack = append(p.recoveryStack, nil)
	} else {
		// slice to 1 more
		p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)+1]
	}

	m := make(map[string]any, len(labels))
	for _, fl := range labels {
		m[fl] = expr
	}
	p.recoveryStack[len(p.recoveryStack)-1] = m
}

// pop a recovery expression from the recoveryStack
func (p *parser) popRecovery() {
	// GC that map
	p.recoveryStack[len(p.recoveryStack)-1] = nil

	p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)-1]
}

func (p *parser) addErr(err error) {
	if p._errPos != nil {
		p.addErrAt(err, *p._errPos, []string{})
	} else {
		p.addErrAt(err, p.pt.position, []string{})
	}
}

func (p *parser) addErrAt(err error, pos position, expected []string) {
	var buf bytes.Buffer
	if p.filename != "" {
		buf.WriteString(p.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%d:%d (%d)", pos.line, pos.col, pos.offset))
	if len(p.rstack) > 0 {
		if buf.Len() > 0 {
			buf.WriteString(": ")
		}
		rule := p.rstack[len(p.rstack)-1]
		if rule.displayName != "" {
			buf.WriteString("rule " + rule.displayName)
		} else {
			buf.WriteString("rule " + rule.name)
		}
	}
	pe := &parserError{Inner: err, pos: pos, prefix: buf.String(), expected: expected}
	p.errs.add(pe)
}

func (p *parser) failAt(fail bool, pos position, want string) {
	// process fail if parsing fails and not inverted or parsing succeeds and invert is set
	if fail == p.maxFailInvertExpected {
		if pos.offset < p.maxFailPos.offset {
			return
		}

		if pos.offset > p.maxFailPos.offset {
			p.maxFailPos = pos
			p.maxFailExpected = p.maxFailExpected[:0]
		}

		if p.maxFailInvertExpected {
			want = "!" + want
		}
		p.maxFailExpected = append(p.maxFailExpected, want)
	}
}

// read advances the parser to the next rune.
func (p *parser) read() {
	p.pt.offset += p.pt.w
	rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
	p.pt.rn = rn
	p.pt.w = n
	p.pt.col++
	if rn == '\n' {
		p.pt.line++
		p.pt.col = 0
	}

	if rn == utf8.RuneError && n == 1 { // see utf8.DecodeRune
		if !p.allowInvalidUTF8 {
			p.addErr(errInvalidEncoding)
		}
	}
}

// restore parser position to the savepoint pt.
func (p *parser) restore(pt savepoint) {
	if pt.offset == p.pt.offset {
		return
	}
	p.pt = pt
}

// get the slice of bytes from the savepoint start to the current position.
func (p *parser) sliceFrom(start savepoint) []byte {
	return p.data[start.position.offset:p.pt.position.offset]
}

func (p *parser) buildRulesTable(g *grammar) {
	p.rules = make(map[string]*rule, len(g.rules))
	for _, r := range g.rules {
		p.rules[r.name] = r
	}
}

// nolint: gocyclo
func (p *parser) parse(g *grammar) (val any, err error) {
	if len(g.rules) == 0 {
		p.addErr(errNoRule)
		return nil, p.errs.err()
	}

	// TODO : not super critical but this could be generated
	p.buildRulesTable(g)

	if p.recover {
		// panic can be used in action code to stop parsing immediately
		// and return the panic as an error.
		defer func() {
			if e := recover(); e != nil {
				val = nil
				switch e := e.(type) {
				case error:
					p.addErr(e)
				default:
					p.addErr(fmt.Errorf("%v", e))
				}
				err = p.errs.err()
			}
		}()
	}

	startRule, ok := p.rules[p.entrypoint]
	if !ok {
		p.addErr(errInvalidEntrypoint)
		return nil, p.errs.err()
	}

	p.read() // advance to first rune
	val, ok = p.parseRuleWrap(startRule)
	if !ok {
		if len(*p.errs) == 0 {
			// If parsing fails, but no errors have been recorded, the expected values
			// for the farthest parser position are returned as error.
			maxFailExpectedMap := make(map[string]struct{}, len(p.maxFailExpected))
			for _, v := range p.maxFailExpected {
				maxFailExpectedMap[v] = struct{}{}
			}
			expected := make([]string, 0, len(maxFailExpectedMap))
			eof := false
			if _, ok := maxFailExpectedMap["!."]; ok {
				delete(maxFailExpectedMap, "!.")
				eof = true
			}
			for k := range maxFailExpectedMap {
				expected = append(expected, k)
			}
			sort.Strings(expected)
			if eof {
				expected = append(expected, "EOF")
			}
			p.addErrAt(errors.New("no match found, expected: "+listJoin(expected, ", ", "or")), p.maxFailPos, expected)
		}

		return nil, p.errs.err()
	}
	return val, p.errs.err()
}

func listJoin(list []string, sep string, lastSep string) string {
	switch len(list) {
	case 0:
		return ""
	case 1:
		return list[0]
	default:
		return strings.Join(list[:len(list)-1], sep) + " " + lastSep + " " + list[len(list)-1]
	}
}

func (p *parser) parseRuleWrap(rule *rule) (any, bool) {
	var (
		val any
		ok  bool
	)

	val, ok = p.parseRule(rule)

	return val, ok
}

func (p *parser) parseRule(rule *rule) (any, bool) {
	p.rstack = append(p.rstack, rule)
	p.pushV()
	val, ok := p.parseExprWrap(rule.expr)
	p.popV()
	p.rstack = p.rstack[:len(p.rstack)-1]
	return val, ok
}

func (p *parser) parseExprWrap(expr any) (any, bool) {
	val, ok := p.parseExpr(expr)

	return val, ok
}

// nolint: gocyclo
func (p *parser) parseExpr(expr any) (any, bool) {
	p.ExprCnt++
	if p.ExprCnt > p.maxExprCnt {
		panic(errMaxExprCnt)
	}

	var val any
	var ok bool
	switch expr := expr.(type) {
	case *actionExpr:
		val, ok = p.parseActionExpr(expr)
	case *andCodeExpr:
		val, ok = p.parseAndCodeExpr(expr)
	case *andExpr:
		val, ok = p.parseAndExpr(expr, false)
	case *andLogicalExpr:
		val, ok = p.parseAndExpr((*andExpr)(expr), true)
	case *anyMatcher:
		val, ok = p.parseAnyMatcher(expr)
	case *charClassMatcher:
		val, ok = p.parseCharClassMatcher(expr)
	case *choiceExpr:
		val, ok = p.parseChoiceExpr(expr)
	case *codeExpr:
		val, ok = p.parseCodeExpr(expr)
	case *labeledExpr:
		val, ok = p.parseLabeledExpr(expr)
	case *litMatcher:
		val, ok = p.parseLitMatcher(expr)
	case *notCodeExpr:
		val, ok = p.parseNotCodeExpr(expr)
	case *notExpr:
		val, ok = p.parseNotExpr(expr, false)
	case *notLogicalExpr:
		val, ok = p.parseNotExpr((*notExpr)(expr), true)
	case *oneOrMoreExpr:
		val, ok = p.parseOneOrMoreExpr(expr)
	case *recoveryExpr:
		val, ok = p.parseRecoveryExpr(expr)
	case *ruleRefExpr:
		val, ok = p.parseRuleRefExpr(expr)
	case *seqExpr:
		val, ok = p.parseSeqExpr(expr)
	case *throwExpr:
		val, ok = p.parseThrowExpr(expr)
	case *zeroOrMoreExpr:
		val, ok = p.parseZeroOrMoreExpr(expr)
	case *zeroOrOneExpr:
		val, ok = p.parseZeroOrOneExpr(expr)
	default:
		panic(fmt.Sprintf("unknown expression type %T", expr))
	}
	return val, ok
}

func (p *parser) parseActionExpr(act *actionExpr) (any, bool) {
	start := p.pt
	val, ok := p.parseExprWrap(act.expr)
	if ok {
		if p.checkSkipCode() {
			return nil, true
		}
		p.cur.pos = start.position
		p.cur.text = p.sliceFrom(start)
		p._errPos = &start.position
		actVal := act.run(p)
		p._errPos = nil

		val = actVal
	}
	return val, ok
}

func (p *parser) parseAndCodeExpr(and *andCodeExpr) (any, bool) {

	ok := and.run(p)

	return nil, ok
}

func (p *parser) parseAndExpr(and *andExpr, logical bool) (any, bool) {
	pt := p.pt
	p.pushV()

	p.scStack = append(p.scStack, true)
	_, ok := p.parseExprWrap(and.expr)
	p.scStack = p.scStack[:len(p.scStack)-1]

	matchedOffset := p.pt.offset
	p.popV()
	p.restore(pt)

	if logical {
		return nil, ok && p.pt.offset != matchedOffset
	}
	return nil, ok
}

func (p *parser) parseAnyMatcher(any *anyMatcher) (any, bool) {
	if p.pt.rn == utf8.RuneError && p.pt.w == 0 {
		// EOF - see utf8.DecodeRune
		p.failAt(false, p.pt.position, ".")
		return nil, false
	}
	start := p.pt
	p.read()
	p.failAt(true, start.position, ".")
	return p.sliceFrom(start), true
}

// nolint: gocyclo
func (p *parser) parseCharClassMatcher(chr *charClassMatcher) (any, bool) {
	cur := p.pt.rn
	start := p.pt

	// can't match EOF
	if cur == utf8.RuneError && p.pt.w == 0 { // see utf8.DecodeRune
		p.failAt(false, start.position, chr.val)
		return nil, false
	}

	if chr.ignoreCase {
		cur = unicode.ToLower(cur)
	}

	// try to match in the list of available chars
	for _, rn := range chr.chars {
		if rn == cur {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of ranges
	for i := 0; i < len(chr.ranges); i += 2 {
		if cur >= chr.ranges[i] && cur <= chr.ranges[i+1] {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of Unicode classes
	for _, cl := range chr.classes {
		if unicode.Is(cl, cur) {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	if chr.inverted {
		p.read()
		p.failAt(true, start.position, chr.val)
		return p.sliceFrom(start), true
	}
	p.failAt(false, start.position, chr.val)
	return nil, false
}

func (p *parser) parseChoiceExpr(ch *choiceExpr) (any, bool) {

	for altI, alt := range ch.alternatives {
		// dummy assignment to prevent compile error if optimized
		_ = altI

		p.pushV()
		val, ok := p.parseExprWrap(alt)
		p.popV()
		if ok {
			return val, ok
		}
	}
	return nil, false
}

func (p *parser) parseLabeledExpr(lab *labeledExpr) (any, bool) {
	start := p.pt
	var val any
	var ok bool
	if lab.textCapture {
		// state := p.cloneState()
		p.pushV()
		// p.scStack = append(p.scStack, true)
		val, ok = p.parseExprWrap(lab.expr)
		// p.scStack = p.scStack[:len(p.scStack)-1]
		p.popV()
		// p.restoreState(state)
	} else {
		p.pushV()
		val, ok = p.parseExprWrap(lab.expr)
		p.popV()
	}
	if ok && lab.label != "" {
		m := p.vstack[len(p.vstack)-1]
		if lab.textCapture {
			m[lab.label] = string(p.sliceFrom(start))
		} else {
			m[lab.label] = val
		}
	}
	return val, ok
}

func (p *parser) parseCodeExpr(code *codeExpr) (any, bool) {
	if !code.notSkip && p.checkSkipCode() {
		return nil, true
	}

	return code.run(p), true
}

func (p *parser) parseLitMatcher(lit *litMatcher) (any, bool) {
	start := p.pt
	for _, want := range lit.val {
		cur := p.pt.rn
		if lit.ignoreCase {
			cur = unicode.ToLower(cur)
		}
		if cur != want {
			p.failAt(false, start.position, lit.want)
			p.restore(start)
			return nil, false
		}
		p.read()
	}
	p.failAt(true, start.position, lit.want)
	return p.sliceFrom(start), true
}

func (p *parser) parseNotCodeExpr(not *notCodeExpr) (any, bool) {
	ok := not.run(p)

	return nil, !ok
}

func (p *parser) parseNotExpr(not *notExpr, logical bool) (any, bool) {
	pt := p.pt
	p.pushV()
	p.maxFailInvertExpected = !p.maxFailInvertExpected

	p.scStack = append(p.scStack, true)
	_, ok := p.parseExprWrap(not.expr)
	p.scStack = p.scStack[:len(p.scStack)-1]

	p.maxFailInvertExpected = !p.maxFailInvertExpected
	p.popV()
	matchedOffset := p.pt.offset
	p.restore(pt)

	if logical {
		return nil, ok && p.pt.offset != matchedOffset
	}
	return nil, !ok
}

func (p *parser) parseOneOrMoreExpr(expr *oneOrMoreExpr) (any, bool) {
	var vals []any

	for {
		p.pushV()
		val, ok := p.parseExprWrap(expr.expr)
		p.popV()
		if !ok {
			if len(vals) == 0 {
				// did not match once, no match
				return nil, false
			}
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseRecoveryExpr(recover *recoveryExpr) (any, bool) {

	p.pushRecovery(recover.failureLabel, recover.recoverExpr)
	val, ok := p.parseExprWrap(recover.expr)
	p.popRecovery()

	return val, ok
}

func (p *parser) parseRuleRefExpr(ref *ruleRefExpr) (any, bool) {
	if ref.name == "" {
		panic(fmt.Sprintf("%s: invalid rule: missing name", ref.pos))
	}

	rule := p.rules[ref.name]
	if rule == nil {
		p.addErr(fmt.Errorf("undefined rule: %s", ref.name))
		return nil, false
	}
	return p.parseRuleWrap(rule)
}

func (p *parser) parseSeqExpr(seq *seqExpr) (any, bool) {
	//vals := make([]any, 0, len(seq.exprs))

	pt := p.pt
	for _, expr := range seq.exprs {
		_, ok := p.parseExprWrap(expr)
		if !ok {
			p.restore(pt)
			return nil, false
		}
		//vals = append(vals, val)
	}
	return nil, true
}

func (p *parser) parseThrowExpr(expr *throwExpr) (any, bool) {

	for i := len(p.recoveryStack) - 1; i >= 0; i-- {
		if recoverExpr, ok := p.recoveryStack[i][expr.label]; ok {
			if val, ok := p.parseExprWrap(recoverExpr); ok {
				return val, ok
			}
		}
	}

	return nil, false
}

func (p *parser) parseZeroOrMoreExpr(expr *zeroOrMoreExpr) (any, bool) {
	var vals []any

	for {
		p.pushV()
		val, ok := p.parseExprWrap(expr.expr)
		p.popV()
		if !ok {
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseZeroOrOneExpr(expr *zeroOrOneExpr) (any, bool) {
	p.pushV()
	val, _ := p.parseExprWrap(expr.expr)
	p.popV()
	// whether it matched or not, consider it a match
	return val, true
}

func rangeTable(class string) *unicode.RangeTable {
	if rt, ok := unicode.Categories[class]; ok {
		return rt
	}
	if rt, ok := unicode.Properties[class]; ok {
		return rt
	}
	if rt, ok := unicode.Scripts[class]; ok {
		return rt
	}

	// cannot happen
	panic(fmt.Sprintf("invalid Unicode class: %s", class))
}
